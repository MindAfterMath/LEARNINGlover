<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta name="author" content="AfterMath" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
<meta name="keywords" content=" algorithm, binary, binary search, conquer, divide, divide and conquer, iteration, list, search, ordered" /> 
<meta name="description" content="This page contains a script I've written to help understand the binary search algorithm." />
<title>Binary Search Algorithm at LEARNINGlover.com</title>
<script type="text/javascript">
function generate(n)
{
	var A = new Array(n);
	var i;
	for (i = 0; i < n; i++)
	{
		next = Math.floor((Math.random())*100);
		if (!linsear(A, next))
			A[i] = next;
		else
			i--;
	}

	return A;
}

function linsear(set, elmnt)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i] == elmnt)
			ans = true;

	return ans;
}

function disp(set)
{
	var text = "";
	text += "set = {";
	for (var i = 0; i < set.length; i++)
	{
		if (i < set.length - 1)
			text += set[i] + ", ";
		else
			text += set[i];
	}
	text += "}";

	return text;
}

function binsear(set, elmnt)
{
	var subset = new Array();
	var mid = Math.floor(set.length / 2);
	var i;
	var ans = "Element Not Found";
//	var text = "";

	text += "We are now going to test " + elmnt + " against the middle element of this set, which is " + set[mid] + ".<br>";

	if (elmnt > set[mid])
	{
		text += "Since " + elmnt + " > " + set[mid] + ", we are going to run the Binary Search Algorithm on the upper half of the array. <br>";
		for (i = mid+1; i < set.length; i++)
		{
			subset[i-(mid+1)] = set[i];
		}
		text += disp(subset) + "<br>";
		if (subset.length > 0)
			ans = binsear(subset, elmnt);
	}
	else if (elmnt < set[mid])
	{
		text += "Since " + elmnt + " < " + set[mid] + ", we are going to run the Binary Search Algorithm on the lower half of the array. <br>";
		for (i = 0; i < mid; i++)
		{
			subset[i] = set[i];
		}
		text += disp(subset) + "<br>";
		if (subset.length > 0)
			ans = binsear(subset, elmnt);
	}
	else if (elmnt == set[mid])
	{
		text += "We have now found the element. <br>";
		ans = "Element Found";
	}
	
	return ans;
}

function quickSort(A, left, right, nest)
{
	var i = left, j = right;
	var tmp;
	if (nest == 0)
	{
		count = 0;
	}
 	var pivot = A[Math.floor((left + right) / 2)];
	while (i <= j)
	{
		while (A[i] < pivot)
			i++;
		while (A[j] > pivot)
			j--;
		if (i <= j)
		{
			tmp = A[i];
			A[i] = A[j];
			A[j] = tmp;
			i++;
			j--;
			count ++;
		}
	}
	if (left < j)
		A = quickSort(A, left, j, nest+1);
	if (i < right)
		A = quickSort(A, i, right, nest+1);
	return A;
}

function init(set, k1)
{
	var set = generate(k1);
	set = quickSort(set, 0, k1-1, 0);
	var ans = new Array();
	var torf = Math.floor((Math.random())*2);
	var elmnt;
	if (!torf)
		elmnt = Math.floor((Math.random())*100);
	else
	{
		elmnt = Math.floor((Math.random())*k1);
		elmnt = set[elmnt];
	}
	var text = "";

	text += "k1 = " + k1 + "<br>";
	text += "set = {";
	for (var i = 0; i < set.length; i++)
	{
		if (i < set.length - 1)
			text += set[i] + ", ";
		else
			text += set[i];
		ans[ans.length] = set[i];
	}
	text += "}<br>";

	text += "element = " + elmnt + "<br>";
	ans[ans.length] = elmnt;
	
	document.getElementById("list").innerHTML = text;
	return ans;
}

function retreive(set, start, finish)
{
	var i;
	var ans = new Array();
	for (i = start; i < finish; i++)
		ans[ans.length] = set[i];
	return ans;
}
</script>
</head>
<body>
<h3><center>Binary Search Algorithm</center></h3><p>This code executes the Binary Search Algorithm. <br>

<br>
In order for this algorithm to be applicable, we need to assume that we're dealing with a sorted list to start. As a result, instead of proceeding iteratively through each item in the list, the binary search algorithm continually divides the list into two halves and searches each half for the element. <br>
<br>
It can be shown that this algorithm requires a maximum number of iterations along the order of log<sub>2</sub>(n), where n is the number of items in the list. 
</p><form name=data id=data> 
<input type=button onclick="k1 = Math.floor(Math.random()*20)+5;ans = init(set1, k1);set1 = retreive(ans, 0, k1);elmnt = retreive(ans, k1, k1+1); document.getElementById('show').checked = false; document.getElementById('output').innerHTML = '';" value="New Problem"><br> 
<p id=list name=list></p>
<br>
<input type="checkbox" name="show" id="show">Show Work?
<input type="button" value="Binary Search" onclick="document.getElementById('output').innerHTML = '';ans = binsear(set1, elmnt); if (document.getElementById('show').checked == true) document.getElementById('output').innerHTML += text; document.getElementById('output').innerHTML += ans;">  
</FORM>
<script type="text/javascript">
var k1 = Math.floor(Math.random()*20)+5;
var set1 = new Array();
var elmnt;
var ans = init(set1, k1);
set1 = retreive(ans, 0, k1);
elmnt = retreive(ans, k1, k1+1);
var text = "";
</script>
<p name="output" id="output"></p></body></html>