<html>
<html>
<head>
<title>Grid Coloring</title>
<style type="text/css">
#wrapper
{

}

table.grid  
{    
	border: 0.1em solid;
	border-collapse:collapse; 
}

td.grid  
{   
	border: 0.1em solid; 
	width: 2em;  
}

th.grid  
{   
	border: 0.1em solid;    
}

table.outer
{
	border-collapse:collapse;
	border: 0.1em solid;
	border-spacing: 0px;
}

td.outer  
{   
	padding: 0px;
	border: 0.1em solid;
	width: 2em; 
}

table.inner
{
	width:100%;
	border-collapse:collapse; 
	border: none;
}

span 
{
	cursor:pointer;
	color:blue;
	text-decoration:underline;
}
</style>
<script type="text/javascript">
function buildLookup()
{
	var temp = new Array(numRows * numClms);
	var count = 0;
	
	for (var i = 0; i < temp.length; i++)
	{
		temp[i] = new Array(2);
	}

	for (var line = 0; line < numRows + numClms; line++)
	{
		for (var i = 0; i <= line; i++)
		{
			var j = line - i;
			if (i >= 0 && j >= 0 && i < numRows && j < numClms)
			{
				temp[count][0] = i;
				temp[count][1] = j;
				count++;
			}
		}
	}

	return temp;
}
	
function buildLookup2()
{
	var temp = [];
	for (var i = 0; i < numRows; i++)
	{
		temp[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			temp[i][j] = -1;
		}
	}
	
	for (var i = 0; i < lookup.length; i++)
	{
		temp[lookup[i][0]][lookup[i][1]] = i;
	}
	
	return temp;
}

function toStr(grid)
{
	var text = "";
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			text += "_";
		}
	}
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (grid[i][j] != -1)
			{
				var loc = lookup2[i][j];
				if (loc != 0)
				{
					text = text.substring(0, loc) + grid[i][j] + text.substring(loc + 1, text.length);
				}
				else
				{
					text = grid[i][j] + text.substring(loc + 1, text.length);
				}
			}
		}
	}
	
	return text;
}

function copyGrid(grid)
{
	var grid2 = [];
	
	for (var rowPtr = 0; rowPtr < numRows; rowPtr++)
	{
		grid2[rowPtr] = [];
		for (var clmPtr = 0; clmPtr < numClms; clmPtr++)
		{
			if (grid.charAt(lookup2[rowPtr][clmPtr]) != '_')
			{
				grid2[rowPtr][clmPtr] = grid[lookup2[rowPtr][clmPtr]];
			}
			else
			{
				grid2[rowPtr][clmPtr] = -1;
			}
		}
	}
	
	return grid2;
}

function updatePoss(grid, poss, cell = -1)
{	
	var rfs = setRFS();
	var color = -1;
	if (rfs != -1)
	{
//		console.log("rfs is set");
		for (var row = 0; row < numRows; row++)
		{
			for (var clm = 0; clm < numClms; clm++)
			{
				if (rfs[row][clm] != -1)
				{
					color = rfs[row][clm];
					poss[row][clm][color] = true;
					for (var clr = 0; clr < numClrs; clr++)
					{
						if (clr != color)
						{
							poss[row][clm][clr] = false;
						}
					}
				}
			}
		}
		
		for (var row = 0; row < numRows; row++)
		{
			for (var clm = 0; clm < numClms; clm++)
			{
				if (rfs[row][clm] == -1)
				{
					poss[row][clm][color] = false;
				}
			}
		}
		
		return poss;
	}
	
	if (cell == -1)
	{
		var locs = [];
		
		for (var i = 0; i < numRows * numClms; i++)
		{
			locs[i] = [];
			for (var k = 0; k < numClrs; k++)
			{
				locs[i][k] = [];
			}
		}
		
		for (var i1 = 0; i1 < numRows; i1++)
		{
			for (var j1 = 0; j1 < numClms; j1++)
			{
				for (var i2 = i1 + 1; i2 < numRows; i2++)
				{
					for (var j2 = j1 + 1; j2 < numClms; j2++)
					{
						if (grid[i1][j1] != -1 && 
						grid[i1][j1] == grid[i1][j2] && grid[i1][j1] == grid[i2][j1])
						{
							if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i1][j1]) == -1)
							{
								locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i1][j1]);
							}
							if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i1][j2]) == -1)
							{
								locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i1][j2]);
							}
							if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i2][j1]) == -1)
							{
								locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i2][j1]);
							}
						}
						
						if (grid[i1][j2] != -1 && 
						grid[i1][j2] == grid[i1][j1] && grid[i1][j2] == grid[i2][j2])
						{
							if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i1][j2]) == -1)
							{
								locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i1][j2]);
							}
							if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i1][j1]) == -1)
							{
								locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i1][j1]);
							}
							if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i2][j2]) == -1)
							{
								locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i2][j2]);
							}
						}
						
						if (grid[i2][j1] != -1 && 
						grid[i2][j1] == grid[i1][j1] && grid[i2][j1] == grid[i2][j2])
						{
							if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i2][j1]) == -1)
							{
								locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i2][j1]);
							}
							if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i1][j1]) == -1)
							{
								locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i1][j1]);
							}
							if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i2][j2]) == -1)
							{
								locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i2][j2]);
							}
						}
						
						if (grid[i2][j2] != -1 && 
						grid[i2][j2] == grid[i1][j2] && grid[i2][j2] == grid[i2][j1])
						{
							if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i2][j2]) == -1)
							{
								locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i2][j2]);
							}
							if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i1][j2]) == -1)
							{
								locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i1][j2]);
							}
							if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i2][j1]) == -1)
							{
								locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i2][j1]);
							}
						}
					}
				}
			}
		}
		
		for (var i = 0; i < numRows * numClms; i++)
		{
			var row = lookup[i][0];
			var clm = lookup[i][1];
			for (var k = 0; k < numClrs; k++)
			{
//				console.log(i + "\t" + row + ", " + clm + "\t" + locs[i][k]);
				if (locs[i][k].length < 3)
				{
					poss[row][clm][k] = true;
				}
				else
				{
					poss[row][clm][k] = false;
				}
			}
		}
		
/*		for (var row1 = 0; row1 < numRows; row1++)
		{	
			for (var clm1 = 0; clm1 < numClms; clm1++)
			{	
				for (var row2 = row1 + 1; row2 < numRows; row2++)
				{	
					for (var clm2 = clm1 + 1; clm2 < numClms; clm2++)
					{
						if (grid[row1][clm1] != -1 && poss[row2][clm2][grid[row1][clm1]] && (grid[row1][clm1] == grid[row1][clm2]) && grid[row1][clm1] == grid[row2][clm1])
						{
							poss[row2][clm2][grid[row1][clm1]] = false;
						}
					
						else if (grid[row1][clm1] != -1 && poss[row2][clm1][grid[row1][clm1]] && (grid[row1][clm1] == grid[row1][clm2]) && grid[row1][clm1] == grid[row2][clm2])
						{
							poss[row2][clm1][grid[row1][clm1]] = false;
						}
						
						else if (grid[row1][clm1] != -1 && poss[row1][clm2][grid[row1][clm1]] && (grid[row1][clm1] == grid[row2][clm2]) && grid[row1][clm1] == grid[row2][clm1])
						{
							poss[row1][clm2][grid[row1][clm1]] = false;
						}
					
						else if (grid[row2][clm2] != -1 && poss[row1][clm1][grid[row2][clm2]] && (grid[row2][clm2] == grid[row1][clm2]) && grid[row2][clm2] == grid[row2][clm1])
						{
							poss[row1][clm1][grid[row2][clm2]] = false;
						}
						else if (grid[row1][clm1] != -1 && poss[row2][clm2][
					}
				}
			}
		}*/
	}
	else
	{
		var i2 = lookup[cell][0];
		var j2 = lookup[cell][1];
		var locs = [];
		
		for (var i = 0; i < numRows * numClms; i++)
		{
			locs[i] = [];
			for (var k = 0; k < numClrs; k++)
			{
				locs[i][k] = [];
			}
		}

		for (var i1 = 0; i1 < numRows; i1++)
		{
			for (var j1 = 0; j1 < numClms; j1++)
			{
				if (i1 != i2 && j1 != j2 && grid[i1][j1] != -1 && grid[i1][j1] == grid[i1][j2] && grid[i1][j1] == grid[i2][j1])
				{
//					console.log(i1 + ", " + j1 + "\t" + "case1");
					if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i1][j1]) == -1)
					{
						locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i1][j1]);
					}
					if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i1][j2]) == -1)
					{
						locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i1][j2]);
					}
					if (locs[lookup2[i2][j2]][grid[i1][j1]].indexOf(lookup2[i2][j1]) == -1)
					{
						locs[lookup2[i2][j2]][grid[i1][j1]].push(lookup2[i2][j1]);
					}
				}
				
				if (i1 != i2 && j1 != j2 && grid[i1][j2] != -1 && grid[i1][j2] == grid[i1][j1] && grid[i1][j2] == grid[i2][j2])
				{
//					console.log(i1 + ", " + j1 + "\t" + "case2");
					if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i1][j2]) == -1)
					{
						locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i1][j2]);
					}
					if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i1][j1]) == -1)
					{
						locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i1][j1]);
					}
					if (locs[lookup2[i2][j1]][grid[i1][j2]].indexOf(lookup2[i2][j2]) == -1)
					{
						locs[lookup2[i2][j1]][grid[i1][j2]].push(lookup2[i2][j2]);
					}
				}
				
				if (i1 != i2 && j1 != j2 && grid[i2][j1] != -1 && grid[i2][j1] == grid[i1][j1] && grid[i2][j1] == grid[i2][j2])
				{
//					console.log(i1 + ", " + j1 + "\t" + "case3");
					if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i2][j1]) == -1)
					{
						locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i2][j1]);
					}
					if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i1][j1]) == -1)
					{
						locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i1][j1]);
					}
					if (locs[lookup2[i1][j2]][grid[i2][j1]].indexOf(lookup2[i2][j2]) == -1)
					{
						locs[lookup2[i1][j2]][grid[i2][j1]].push(lookup2[i2][j2]);
					}
				}
				
				if (i1 != i2 && j1 != j2 && grid[i2][j2] != -1 && grid[i2][j2] == grid[i1][j2] && grid[i2][j2] == grid[i2][j1])
				{
//					console.log(i1 + ", " + j1 + "\t" + "case4");
					if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i2][j2]) == -1)
					{
						locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i2][j2]);
					}
					if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i1][j2]) == -1)
					{
						locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i1][j2]);
					}
					if (locs[lookup2[i1][j1]][grid[i2][j2]].indexOf(lookup2[i2][j1]) == -1)
					{
						locs[lookup2[i1][j1]][grid[i2][j2]].push(lookup2[i2][j1]);
					}
				}
			}
		}
		
		for (var i = 0; i < numRows * numClms; i++)
		{
			var row = lookup[i][0];
			var clm = lookup[i][1];
			
//			console.log(row + ", " + clm + "\t" + locs[i]);
			
			for (var k = 0; k < numClrs; k++)
			{
				if (locs[i][k].length < 3 && poss[row][clm][k])
				{
					poss[row][clm][k] = true;
				}
				else
				{
					poss[row][clm][k] = false;
				}
			}
		}
	}
	
	if (document.getElementById("chk1").checked)
	{
		var lowR = Math.floor(numClms / numClrs);		
		var lowC = Math.floor(numRows / numClrs);

		var highR = Math.ceil(numClms / numClrs);		
		var highC = Math.ceil(numRows / numClrs);
		
		var maxHighR = numClms % numClrs;
		var maxHighC = numRows % numClrs;
		
		for (var i = 0; i < numRows; i++)
		{
			var cnt = new Array(numClrs);
			
			for (var k = 0; k < numClrs; k++)
			{
				cnt[k] = 0;
			}
			for (var j = 0; j < numClms; j++)
			{
				if (grid[i][j] != -1)
				{
					cnt[grid[i][j]]++;
				}
			}
			
			var numHighThisRow = 0;
			for (var k = 0; k < numClrs; k++)
			{
				if (cnt[k] == highR)
				{
					numHighThisRow++;
					for (var j = 0; j < numClms; j++)
					{
						if (grid[i][j] == -1)
						{
							poss[i][j][k] = false;
						}
					}
				}
			}
			
			if (numHighThisRow == maxHighR)
			{
				for (var k = 0; k < numClrs; k++)
				{
					if (cnt[k] == highR-1)
					{
						for (var j = 0; j < numClms; j++)
						{
							if (grid[i][j] == -1)
							{
								poss[i][j][k] = false;
							}
						}
					}
				}
			}		
		}
			
		for (var j = 0; j < numClms; j++)
		{
			var cnt = new Array(numClrs);
			
			for (var k = 0; k < numClrs; k++)
			{
				cnt[k] = 0;
			}
			for (var i = 0; i < numRows; i++)
			{
				if (grid[i][j] != -1)
				{
					cnt[grid[i][j]]++;
				}
			}
			
			var numHighThisClm = 0;
			for (var k = 0; k < numClrs; k++)
			{
				if (cnt[k] == maxHighC)
				{
					numHighThisClm++;
					for (var i = 0; i < numRows; i++)
					{
						if (grid[i][j] == -1)
						{
							poss[i][j][k] = false;
						}
					}
				}
			}
		}
	}
	
	return poss;
}

function initPoss()
{
	var temp = [];
	
	for (var i = 0; i < numRows; i++)
	{
		temp[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			temp[i][j] = [];
			for (var k = 0; k < numClrs; k++)
			{
				temp[i][j][k] = true;
			}
		}
	}
	
	return temp;
}

function initGrid()
{
	var temp = []; 
	
	for (var i = 0; i < numRows; i++)
	{
		temp[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			temp[i][j] = -1;
		}
	}
	
	return temp;
}

function countPairs(gridMtx)
{
	var pairs = [];
	pairs[0] = 0;
	pairs[1] = 0;
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j1 = 0; j1 < numClms; j1++)
		{
			for (var j2 = j1 + 1; j2 < numClms; j2++)
			{
				if (gridMtx[i][j1] == gridMtx[i][j2] && gridMtx[i][j1] != -1)
				{
					pairs[0]++;
				}
			}
		}
	}
	
	for (var j = 0; j < numClms; j++)
	{
		for (var i1 = 0; i1 < numRows; i1++)
		{
			for (var i2 = i1 + 1; i2 < numRows; i2++)
			{
				if (gridMtx[i1][j] == gridMtx[i2][j] && gridMtx[i1][j] != -1)
				{
					pairs[1]++;
				}
			}
		}
	}

	return pairs;
}

function dispGrid(gridMtx)
{
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] == "0")
			{
				document.getElementById(i + "_" + j).style = "background:rgb(0, 0, 255)";
			}
			else if (gridMtx[i][j] == "1")
			{
				document.getElementById(i + "_" + j).style = "background:rgb(255, 0, 0)";
			}
			else if (gridMtx[i][j] == "2")
			{
				document.getElementById(i + "_" + j).style = "background:rgb(0, 255, 0)";
			}
			else if (gridMtx[i][j] == "3")
			{
				document.getElementById(i + "_" + j).style = "background:rgb(255, 255, 0)";
			}
			else
			{
				document.getElementById(i + "_" + j).style = "background:rgb(255, 255, 255)";
			}
		}
	}
}

function getGrid()
{
	var grd = [];
	
	for (var i = 0; i < numRows; i++)
	{
		grd[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			if (document.getElementById(i + "_" + j).style.background == "#0000FF" || 
				document.getElementById(i + "_" + j).style.background == "rgb(0, 0, 255)" || 
				document.getElementById(i + "_" + j).style.background == "none repeat scroll 0% 0% rgb(0, 0, 255)" ||
				document.getElementById(i + "_" + j).style.background == "rgb(0, 0, 255) none repeat scroll 0% 0%")
			{	
				grd[i][j] = "0";
			}	
			else if (document.getElementById(i + "_" + j).style.background == "#FF0000" || 
				 document.getElementById(i + "_" + j).style.background == "rgb(255, 0, 0)" || 
				 document.getElementById(i + "_" + j).style.background == "none repeat scroll 0% 0% rgb(255, 0, 0)" ||
				 document.getElementById(i + "_" + j).style.background == "rgb(255, 0, 0) none repeat scroll 0% 0%")
			{	 
				grd[i][j] = "1";
			}	
			else if (document.getElementById(i + "_" + j).style.background == "#00FF00" || 
				 document.getElementById(i + "_" + j).style.background == "rgb(0, 255, 0)" || 
				 document.getElementById(i + "_" + j).style.background == "none repeat scroll 0% 0% rgb(0, 255, 0)" ||
				 document.getElementById(i + "_" + j).style.background == "rgb(0, 255, 0) none repeat scroll 0% 0%")
			{
				grd[i][j] = "2";
			}
			else if (document.getElementById(i + "_" + j).style.background == "#FFFF00" || 
				 document.getElementById(i + "_" + j).style.background == "rgb(255, 255, 0)" || 
				 document.getElementById(i + "_" + j).style.background == "none repeat scroll 0% 0% rgb(255, 255, 0)" ||
				 document.getElementById(i + "_" + j).style.background == "rgb(255, 255, 0) none repeat scroll 0% 0%")
			{
				grd[i][j] = "3";
			}
			else
			{
				grd[i][j] = "-1";
			}
		}
	}
	
	return toStr(grd);
}

function hasRect(gridMtx)
{
	var found = false;
	
	for (var row1 = 0; row1 < numRows && !found; row1++)
	{
		for (var row2 = row1 + 1; row2 < numRows && !found; row2++)
		{
			for (var clm1 = 0; clm1 < numClms && !found; clm1++)
			{
				for (var clm2 = clm1 + 1; clm2 < numClms && !found; clm2++)
				{
					if (gridMtx[row1][clm1] != -1 && 
						gridMtx[row1][clm1] == gridMtx[row1][clm2] && 
						gridMtx[row1][clm1] == gridMtx[row2][clm1] && 
						gridMtx[row1][clm1] == gridMtx[row2][clm2])
					{
						found = true;
					}
				}
			}
		}
	}
	
	return found;
}

function changecolor(id)
{
	if (numClrs == 4)
	{
		if (document.getElementById(id).style.background == "#0000FF" || 
			document.getElementById(id).style.background == "rgb(0, 0, 255)" || 
			document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(0, 0, 255)" ||
			document.getElementById(id).style.background == "rgb(0, 0, 255) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#FF0000";
		}
		else if (document.getElementById(id).style.background == "#FF0000" || 
				 document.getElementById(id).style.background == "rgb(255, 0, 0)" || 
				 document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(255, 0, 0)" ||
				 document.getElementById(id).style.background == "rgb(255, 0, 0) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#00FF00";
		}
		else if (document.getElementById(id).style.background == "#00FF00" || 
				 document.getElementById(id).style.background == "rgb(0, 255, 0)" || 
				 document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(0, 255, 0)" ||
				 document.getElementById(id).style.background == "rgb(0, 255, 0) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#FFFF00";
		}
		else if (document.getElementById(id).style.background == "#FFFF00" || 
				 document.getElementById(id).style.background == "rgb(255, 255, 0)" || 
				 document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(255, 255, 0)" ||
				 document.getElementById(id).style.background == "rgb(255, 255, 0) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#FFFFFF";
		}
		else
		{
			document.getElementById(id).style.background = "#0000FF";
		}
	}
	else if (numClrs == 3)
	{
		if (document.getElementById(id).style.background == "#0000FF" || 
			document.getElementById(id).style.background == "rgb(0, 0, 255)" || 
			document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(0, 0, 255)" ||
			document.getElementById(id).style.background == "rgb(0, 0, 255) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#FF0000";
		}
		else if (document.getElementById(id).style.background == "#FF0000" || 
				 document.getElementById(id).style.background == "rgb(255, 0, 0)" || 
				 document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(255, 0, 0)" ||
				 document.getElementById(id).style.background == "rgb(255, 0, 0) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#00FF00";
		}
		else if (document.getElementById(id).style.background == "#00FF00" || 
				 document.getElementById(id).style.background == "rgb(0, 255, 0)" || 
				 document.getElementById(id).style.background == "none repeat scroll 0% 0% rgb(0, 255, 0)" ||
				 document.getElementById(id).style.background == "rgb(0, 255, 0) none repeat scroll 0% 0%")
		{
			document.getElementById(id).style.background = "#FFFFFF";
		}
		else
		{
			document.getElementById(id).style.background = "#0000FF";
		}
	}
	
	feas(-1, copyGrid(getGrid()));
}

function clrGrd()
{
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			document.getElementById(i + "_" + j).style = "background:rgb(255, 255, 255)";
		}
	}
	document.getElementById("metrics").innerHTML = "";
	document.getElementById("possGrid").innerHTML = "";
	document.getElementById("output").innerHTML = "";
}

function eqDist(grid)
{
	var lowR = Math.floor(numClms / numClrs);		
	var lowC = Math.floor(numRows / numClrs);

	var highR = Math.ceil(numClms / numClrs);		
	var highC = Math.ceil(numRows / numClrs);
	
	var maxHighR = numClms % numClrs;
	var maxHighC = numRows % numClrs;
	
//	var feasib = true;
	
	for (var i = 0; i < numRows; i++)
	{
		var cnt = new Array(numClrs);
		
		for (var k = 0; k < numClrs; k++)
		{
			cnt[k] = 0;
		}
		for (var j = 0; j < numClms; j++)
		{
			if (grid[i][j] != -1)
			{
				cnt[grid[i][j]]++;
				if (cnt[grid[i][j]] > highR)
				{
					return false;
				}
			}
		}
		
		var numHighThisRow = 0;
		for (var k = 0; k < numClrs; k++)
		{
			if (cnt[k] == highR)
			{
				numHighThisRow++;
			}
		}
		if (numHighThisRow > maxHighR)
		{
			return false;
		}
		
		if (grid[i][numClms-1] != -1)
		{
			for (var k = 0; k < numClrs; k++)
			{
				if (cnt[k] < lowR)
				{
					return false;
				}
			}
		}
	}
		
	for (var j = 0; j < numClms; j++)
	{
		var cnt = new Array(numClrs);
		
		for (var k = 0; k < numClrs; k++)
		{
			cnt[k] = 0;
		}
		for (var i = 0; i < numRows; i++)
		{
			if (grid[i][j] != -1)
			{
				cnt[grid[i][j]]++;
				if (cnt[grid[i][j]] > highC)
				{
					return false;
				}
			}
		}
		
		var high = 0;
		for (var k = 0; k < numClrs; k++)
		{
			if (cnt[k] == highC)
			{
				high++;
			}
		}
		if (high > maxHighC)
		{
			return false;
		}
		
		if (grid[numRows-1][j] != -1)
		{
			for (var k = 0; k < numClrs; k++)
			{
				if (cnt[k] < lowC)
				{
					return false;
				}
			}
		}
	}
	
	return true;
}

function showPoss(grid1)
{
//	var grid1 = getGrid();
	var grid = copyGrid(grid1);
	var poss = updatePoss(grid, initPoss());
	
	var out = "<table class='outer'><tr><td class='outer'>&nbsp;</td>";
	for (var j = 0; j < numClms; j++)
	{
		out += "<td class='outer'>" + j + "</td>";
	}
	out += "</tr>";
	
	for (var i = 0; i < numRows; i++)
	{
		out += "<tr><td class='outer'>" + i + "</td>";
		for (var j = 0; j < numClms; j++)
		{
			out += "<td class='outer'><table class='inner'><tr>"
			for (var k = 0; k < numClrs; k++)
			{
				if (poss[i][j][k])
				{
					out += "<td style='background:rgb(";
					if (k == 0)
					{
						out += "0, 0, 255";
					}
					else if (k == 1)
					{
						out += "255, 0, 0";
					}
					else if (k == 2)
					{
						out += "0, 255, 0";
					}
					else if (k == 3)
					{
						out += "255, 255, 0";
					}
					out += ")'>&nbsp</td>";
				}
			}
			out += "</tr></table>"
		}
		out += "</tr>";
	}
	out += "</table>";
	
	document.getElementById("possGrid").innerHTML = out;
}

function randInst(start)
{
	var len = start.indexOf("_");
	if (len == -1)
	{
		return start;
	}

	var grd = copyGrid(start);
	var poss2 = updatePoss(grd, initPoss());
	
	for (var cell = len; cell < numRows * numClms; cell++)
	{
		var clrs = [];
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		
		var clrcnt1 = [];
		var clrcnt2 = [];
		var clrcnt3 = [];
		var clrcnt4 = [];
		var clrcnt5 = [];
		var clrcnt6 = [];
		var clrcnt7 = [];
		for (var k = 0; k < numClrs; k++)
		{
			grd[row][clm] = k;
			poss2 = updatePoss(grd, poss2, cell);
			if (poss2[row][clm][k])
			{
				if ((document.getElementById("chk1").checked && eqDist(grd)) || !document.getElementById("chk1").checked)
				{
					clrs.push(k);
					clrcnt1.push(possPairs(grd, poss2));
					clrcnt2.push(getDiffs(grd));
					clrcnt3.push(countLs(grd));
					clrcnt4.push(countPairs(grd));
					clrcnt5.push(nonSings(grd, poss2));
					clrcnt6.push(minAppear(grd));
					clrcnt7.push(getOvlps(grd));
				}
			}
			grd[row][clm] = -1;
		}
		
		if (clrs.length > 0)
		{
			var alg = Math.floor(Math.random() * 8);
			if (alg == 0)
			{
				grd[row][clm] = clrs[Math.floor(Math.random() * clrs.length)];			
			}
			else if (alg == 1)
			{
				var max = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt1[k] > clrcnt1[max])
					{
						max = k;
					}
				}
				grd[row][clm] = clrs[max];
			}
			else if (alg == 2)
			{
				var min = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt2[k] < clrcnt2[min])
					{
						min = k;
					}
				}
				grd[row][clm] = clrs[min];
			}
			else if (alg == 3)
			{
				var min = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt3[k] < clrcnt3[min])
					{
						min = k;
					}
				}
				grd[row][clm] = clrs[min];
			}
			else if (alg == 4)
			{
				var min = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt4[k] < clrcnt4[min])
					{
						min = k;
					}
				}
				grd[row][clm] = clrs[min];
			}
			else if (alg == 5)
			{
				var max = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt5[k] > clrcnt5[max])
					{
						max = k;
					}
				}
				grd[row][clm] = clrs[max];
			}
			else if (alg == 6)
			{
				var max = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt6[k] > clrcnt6[max])
					{
						max = k;
					}
				}
				grd[row][clm] = clrs[max];
			}
			else if (alg == 7)
			{
				var min = 0;
				for (var k = 0; k < clrs.length; k++)
				{
					if (clrcnt7[k] < clrcnt7[min])
					{
						min = k;
					}
				}
				grd[row][clm] = clrs[min];
			}
		}
		else
		{
//			console.log(cell + "(" + row + ", " + clm + ") has no options ");
//			console.log(poss2[row][clm]);
			break;
		}
	}
	
	return(grd);
}

function conflict(gridMtx)
{
	var locs = [];
	var loc = toStr(gridMtx).indexOf("_");
	
	if (loc == -1)
	{
		return numRows*numClms;
	}
	
	var row = lookup[loc][0];
	var clm = lookup[loc][1];
	var oldCell = -1;

	for (var i = 0; i < numRows * numClms; i++)
	{
		locs[i] = [];
		for (var k = 0; k < numClrs; k++)
		{
			locs[i][k] = [];
		}
	}
	
	for (var i1 = 0; i1 < numRows; i1++)
	{
		for (var j1 = 0; j1 < numClms; j1++)
		{
			for (var i2 = i1 + 1; i2 < numRows; i2++)
			{
				for (var j2 = j1 + 1; j2 < numClms; j2++)
				{
					if (gridMtx[i1][j1] != -1 && 
					gridMtx[i1][j1] == gridMtx[i1][j2] && gridMtx[i1][j1] == gridMtx[i2][j1])
					{
						if (locs[lookup2[i2][j2]][gridMtx[i1][j1]].indexOf(lookup2[i1][j1]) == -1)
						{
							locs[lookup2[i2][j2]][gridMtx[i1][j1]].push(lookup2[i1][j1]);
						}
						if (locs[lookup2[i2][j2]][gridMtx[i1][j1]].indexOf(lookup2[i1][j2]) == -1)
						{
							locs[lookup2[i2][j2]][gridMtx[i1][j1]].push(lookup2[i1][j2]);
						}
						if (locs[lookup2[i2][j2]][gridMtx[i1][j1]].indexOf(lookup2[i2][j1]) == -1)
						{
							locs[lookup2[i2][j2]][gridMtx[i1][j1]].push(lookup2[i2][j1]);
						}
					}
				}
			}
		}
	}
	
	var list = [];
	
	for (var i = 0; i < loc; i++)
	{
		var sum = 0;
		for (var k = 0; k < numClrs; k++)
		{
			if (locs[i][k].length > 0)
			{
				sum++;
			}
		}
		
		if (sum == numClrs - 1)
		{
			list.push(i);
		}
	}

	return list;
}

function firstSing(grid, poss)
{
	var cnts = [];
	for (var i = 0; i < numRows; i++)
	{
		cnts[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			cnts[i][j] = 0;
			for (var k = 0; k < numClrs; k++)
			{
				if (poss[i][j][k])
				{
					cnts[i][j]++;
				}
			}
		}
	}
	
	for (var i = 0; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		
		if (cnts[row][clm] == 1)
		{
			return i;
		}
	}
	
	return -1;
}

function nonSings(grid, poss)
{
	var len = toStr(grid).indexOf("_");
	var cnts = [];
	for (var i = 0; i < numRows; i++)
	{
		cnts[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			cnts[i][j] = 0;
			for (var k = 0; k < numClrs; k++)
			{
				if (poss[i][j][k])
				{
					cnts[i][j]++;
				}
			}
		}
	}
	
	var total = 0;
	
	for (var i = 0; i < len; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		
		if (cnts[row][clm] > 1)
		{
//			total += cnts[row][clm];
			total++;
		}
	}
	
	return total;
}

function possPairs(grid, poss)
{
	var pairs = 0;
	var last = toStr(grid).indexOf("_");
	last = numRows * numClms;
	var usedR = [];
	for (var j = 0; j < numClms; j++)
	{
		for (var i1 = 0; i1 < numRows; i1++)
		{
			for (var i2 = i1 + 1; i2 < numRows; i2++)
			{
				if (grid[i1][j] == grid[i2][j] && grid[i1][j] != -1)
				{
					var len = usedR.length;
					usedR[len] = [];
					usedR[len][0] = i1;
					usedR[len][1] = i2;
					usedR[len][2] = grid[i1][j];
				}
			}
		}
	}
	
	var usedC = [];
	for (var i = 0; i < numRows; i++)
	{
		for (var j1 = 0; j1 < numClms; j1++)
		{
			for (var j2 = j1 + 1; j2 < numClms; j2++)
			{
				if (grid[i][j1] == grid[i][j2] && grid[i][j1] != -1)
				{
					var len = usedC.length;
					usedC[len] = [];
					usedC[len][0] = j1;
					usedC[len][1] = j2;
					usedC[len][2] = grid[i][j1];
				}
			}
		}
	}
	
	for (var k = 0; k < numClrs; k++)
	{
		for (var i = 0; i < numRows; i++)
		{
			for (var j1 = 0; j1 < numClms; j1++)
			{
				for (var j2 = j1 + 1; j2 < numClms; j2++)
				{
					var fnd = false;
					for (var cntr = 0; cntr < usedC.length; cntr++)
					{
						if (usedC[cntr][0] == j1 && usedC[cntr][1] == j2 && k == usedC[cntr][2])
						{
							fnd = true;
						}
					}
						
					if (lookup2[i][j1] <= last && lookup2[i][j2] <= last && poss[i][j1][k] && poss[i][j2][k] && !fnd)
					{
						pairs ++;
					}
				}
			}
		}
		
		for (var j = 0; j < numClms; j++)
		{
			for (var i1 = 0; i1 < numRows; i1++)
			{
				for (var i2 = i1 + 1; i2 < numRows; i2++)
				{
					var fnd = false;
					for (var cntr = 0; cntr < usedR.length; cntr++)
					{
						if (usedR[cntr][0] == i1 && usedR[cntr][1] == i2 && k == usedR[cntr][2])
						{
							fnd = true;
						}
					}
					
					if (lookup2[i1][j] <= last && lookup2[i2][j] <= last && poss[i1][j][k] && poss[i2][j][k] && !fnd)
					{
						pairs ++;
					}
				}
			}
		}
	}
	
	return pairs;
}

function minAppear(gridMtx)
{
	var rCount = [];
	var cCount = [];
	
	for (var i = 0; i < numRows; i++)
	{
		rCount[i] = [];
	}

	for (var j = 0; j < numClms; j++)
	{
		cCount[j] = [];
	}
	
	for (var k = 0; k < numClrs; k++)
	{
		for (var i = 0; i < numRows; i++)
		{
			rCount[i][k] = 0;
		}

		for (var j = 0; j < numClms; j++)
		{
			cCount[j][k] = 0;
		}
	}
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] != -1)
			{
				rCount[i][gridMtx[i][j]]++;
				cCount[j][gridMtx[i][j]]++;
			}
		}
	}
	
	var min = Number.MAX_VALUE;
	
	for (var i = 0; i < numRows; i++)
	{
		for (var k = 0; k < numClrs; k++)
		{
			if (rCount[i][k] < min && gridMtx[i][numClms-1] != -1)
			{
				min = rCount[i][k];
			}
		}
	}
	
	for (var j = 0; j < numClms; j++)
	{
		for (var k = 0; k < numClrs; k++)
		{
			if (cCount[j][k] < min && gridMtx[numRows-1][j] != -1)
			{
				min = cCount[j][k];
			}
		}
	}
	
	return min;
}

function countLs(grid)
{
	var clrs = [];
	for (var k = 0; k < numClrs;  k++)
	{
		clrs[k] = 0;
	}

	for (var row1 = 0; row1 < numRows; row1++)
	{
		for (var row2 = row1 + 1; row2 < numRows; row2++)
		{
			for (var clm1 = 0; clm1 < numClms; clm1++)
			{
				for (var clm2 = clm1 + 1; clm2 < numClms; clm2++)
				{
					if (grid[row1][clm1] == grid[row1][clm2] && grid[row1][clm1] == grid[row2][clm1] && grid[row1][clm1] != -1)
					{
						clrs[grid[row1][clm1]]++;
					}
					if (grid[row1][clm1] == grid[row1][clm2] && grid[row1][clm1] == grid[row2][clm2] && grid[row1][clm1] != -1)
					{
						clrs[grid[row1][clm1]]++;
					}
					if (grid[row1][clm1] == grid[row2][clm1] && grid[row1][clm1] == grid[row2][clm2] && grid[row1][clm1] != -1)
					{
						clrs[grid[row1][clm1]]++;
					}
					if (grid[row2][clm1] == grid[row1][clm2] && grid[row2][clm1] == grid[row2][clm2] && grid[row2][clm1] != -1)
					{
						clrs[grid[row2][clm1]]++;
					}
				}
			}
		}
	}
	
	var ans = 0;
	
	for (var k = 0; k < numClrs; k++)
	{
		ans += clrs[k];
	}
	
	return ans;
}

function getDiffs(grid)
{
	var rCount = [];
	var cCount = [];
	var diffs = 0;
	
	for (var i = 0; i < numRows; i++)
	{
		rCount[i] = [];
		for (var k = 0; k < numClrs; k++)
		{
			rCount[i][k] = 0;
		}
	}
	
	for (var j = 0; j < numClms; j++)
	{
		cCount[j] = [];
		for (var k = 0; k < numClrs; k++)
		{
			cCount[j][k] = 0;
		}
	}
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (grid[i][j] != -1)
			{
				rCount[i][grid[i][j]]++;
				cCount[j][grid[i][j]]++;
			}
		}
	}
	
	for (var i = 0; i < numRows; i++)
	{
		for (var k1 = 0; k1 < numClrs; k1++)
		{
			for (var k2 = k1 + 1; k2 < numClrs; k2++)
			{
				diffs += Math.abs(rCount[i][k1] - rCount[i][k2]);
			}
		}
	}
	
	for (var j = 0; j < numClms; j++)
	{
		for (var k1 = 0; k1 < numClrs; k1++)
		{
			for (var k2 = k1 + 1; k2 < numClrs; k2++)
			{
				diffs += Math.abs(cCount[j][k1] - cCount[j][k2]);
			}
		}
	}
	
	return diffs;
}

function getOvlps(gridMtx)
{
	var last = toStr(gridMtx).indexOf("_");
	var locs = [];
	
	for (var cell = 0; cell <= last; cell++)
	{
		var row2 = lookup[cell][0];
		var clm2 = lookup[cell][1];
		locs[cell] = [];
		
		for (var i = 0; i < cell; i++)
		{
			var row1 = lookup[i][0];
			var clm1 = lookup[i][1];
			
			if (gridMtx[row1][clm1] == gridMtx[row1][clm2] && gridMtx[row1][clm1] == gridMtx[row2][clm1] && row1 != row2 && clm1 != clm2)
			{
				var rect = [];
				rect[0] = row1 + "_" + clm1;
				rect[1] = row1 + "_" + clm2;
				rect[2] = row2 + "_" + clm1;
				locs[cell][locs[cell].length] = rect;
			}
		}
	}	
}

function chgRdmSub(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	gridMtx2 = copyGrid(gridStr);
	
    var finished = false;
//	var sub = [];
//	for (var i = 0; i < len1; i++)
//	{
//		for (var j = 0; j < i; j++)
//		{
//			sub.push(i);
//		}
//	}
	
//	var subLen = sub[Math.floor(Math.random() * sub.length)];
//	
//	for (var i = subLen; i <= len1; i++)
//	{
//		var row = lookup[i][0];
//		var clm = lookup[i][1];
//		gridMtx2[row][clm] = -1;
//	}
	
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var i = len1-1; i >= 0 && !finished; i--)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		var clrs = [];
		for (var k = 0; k < numClrs; k++)
		{
			if (poss[row][clm][k] && gridMtx[row][clm] != k)
			{
				clrs.push(k);
			}
		}
		
		if (clrs.length == 0)
		{
			gridMtx2[row][clm] = -1;
			poss = updatePoss(gridMtx2, poss, i);
			continue;
		}
		
		gridMtx2[row][clm] = clrs[Math.floor(Math.random() * clrs.length)];
		if (!hasRect(gridMtx2))
		{
			finished = true;
		}
		else
		{
			gridMtx2[row][clm] = -1;
		}
		poss = updatePoss(gridMtx2, poss, i);
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	gridStr2 = toStr(gridMtx2);
		
//	var poss2 = updatePoss(gridMtx2, poss);
	
	document.getElementById("output").innerHTML = "Change Substring<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + gridStr.indexOf("_") + ", " + (gridStr == gridStr2) + "<br>";
	document.getElementById("output").innerHTML += gridStr2 + " - " + gridStr2.indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function clrSwaps(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}	
	
	var keepClr = Math.floor(Math.random() * numClrs);
	var loc = Math.floor(Math.random() * len1);
	var gridMtx2 = copyGrid(gridStr);
	
	for (var cell = loc; cell < numRows * numClms; cell++)
	{
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		if (gridMtx2[row][clm] != keepClr)
		{
			gridMtx2[row][clm] = -1;
		}
	}
		
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var cell = loc; cell < numRows * numClms; cell++)
	{
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		if (gridMtx2[row][clm] == -1)
		{
			var clrs = [];
			for (var k = 0; k < numClrs; k++)
			{
				if (poss[row][clm][k])
				{
					var old = gridMtx2[row][clm];
					gridMtx2[row][clm] = k;
					if ((document.getElementById("chk1").checked && eqDist(gridMtx2)) || !document.getElementById("chk1").checked)
					{
						clrs.push(k);
					}
					gridMtx2[row][clm] = old;
				}
			}
			
			if (clrs.length > 0)
			{
				var newClr = clrs[Math.floor(Math.random() * clrs.length)];
				gridMtx2[row][clm] = newClr;
				poss = updatePoss(gridMtx2, poss, cell);
			}
			else
			{
				break;
			}
		}
	}
	
	var len2 = toStr(gridMtx2).indexOf("_");
	if (len2 == -1)
	{
		len2 = numRows * numClms;
	}
	for (var cell = len2; cell < numRows * numClms; cell++)
	{
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		gridMtx2[row][clm] = -1;
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Color Swaps<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function fixLShapes(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	var gridMtx2 = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	
	var list = conflict(gridMtx);
	var lCount = [];

	var loc = Math.floor(Math.random() * list.length);
		
	for (var i = list[loc]; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		gridMtx2[row][clm] = -1;
	}
	
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var i = list[loc]; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		var clrs = [];
		for (k = 0; k < numClrs; k++)
		{
			if (poss[row][clm][k])
			{
				clrs.push(k);
			}
		}
		
		if (clrs.length > 0)
		{
			gridMtx2[row][clm] = clrs[Math.floor(Math.random() * clrs.length)];
			poss = updatePoss(gridMtx2, poss, i);
		}
		else
		{
			break;
		}
	}
	
	var gridStr2 = toStr(gridMtx2);
	var last = gridStr2.indexOf("_");
	
	for (var i = last; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		
		gridMtx2[row][clm] = -1;
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Fix LShapes<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function fixLShapes2(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	var gridMtx2 = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	
//	var list = conflict(gridMtx);
	
	var row = lookup[len1][0];
	var clm = lookup[len1][1];
	var oldCell = -1;
	var locs = [];

	for (var i1 = 0; i1 < row; i1++)
	{
		for (var j1 = 0; j1 < clm; j1++)
		{
			if (gridMtx[i1][j1] != -1 && gridMtx[i1][clm] != -1 && gridMtx[row][j1] != -1 && 
			gridMtx[i1][j1] == gridMtx[i1][clm] && gridMtx[i1][j1] == gridMtx[row][j1])
			{
				if (locs.indexOf(lookup2[i1][j1]) == -1)
				{
					locs.push(lookup2[i1][j1]);
				}
				if (locs.indexOf(lookup2[i1][clm]) == -1)
				{
					locs.push(lookup2[i1][clm]);
				}
				if (locs.indexOf(lookup2[row][j1]) == -1)
				{
					locs.push(lookup2[row][j1]);
				}
			}
		}
	}
	
	var loc = Math.floor(Math.random() * locs.length);
	
	for (var i = locs[loc]; i < locs.length; i++)
	{
		var row = lookup[locs[i]][0];
		var clm = lookup[locs[i]][1];
		gridMtx2[row][clm] = -1;
	}
	
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var i = 0; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		var clrs = [];
		for (k = 0; k < numClrs; k++)
		{
			if (poss[row][clm][k])
			{
				clrs.push(k);
			}
		}
		
		if (clrs.length > 0)
		{
			gridMtx2[row][clm] = clrs[Math.floor(Math.random() * clrs.length)];
			poss = updatePoss(gridMtx2, poss, i);
		}
		else
		{
			break;
		}
	}
	
	var gridStr2 = toStr(gridMtx2);
	var last = gridStr2.indexOf("_");
	
	for (var i = last; i < numRows * numClms; i++)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		
		gridMtx2[row][clm] = -1;
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Fix L Shapes 2<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function shuffClrs(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	var gridMtx2 = [];
	
	for (var i = 0; i < numRows; i++)
	{
		gridMtx2[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			if (lookup2[i][j] < len1)
			{
				gridMtx2[i][j] = gridMtx[i][j];
			}
			else
			{
				gridMtx2[i][j] = -1;
			}
		}
	}
	
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var cell = 0; cell < numRows * numClms; cell++)
	{
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		var clrs = [];
		for (var clr = 0; clr < numClrs; clr++)
		{
			if (poss[row][clm][clr])
			{
				var old = gridMtx2[row][clm];
				gridMtx2[row][clm] = clr;			
				if ((document.getElementById("chk1").checked && eqDist(gridMtx2)) || !document.getElementById("chk1").checked)
				{
					clrs.push(clr);
				}
				gridMtx2[row][clm] = old;
			}
		}
		
		if (clrs.length >= 1 && gridMtx2[row][clm] != -1)
		{
			var newClr = clrs[Math.floor(Math.random() * clrs.length)];
			gridMtx2[row][clm] = newClr;
			poss = updatePoss(gridMtx2, poss, cell);		
		}
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	
	document.getElementById("output").innerHTML = "Shuffle Colors<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";

	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function shuffClrs2(keep, gridStr)
{
	var len1 = gridStr.indexOf("_");
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	
	var len2 = len1 - (Math.floor(Math.random() * 5) + 1);
	var gridMtx2 = [];
	
	for (var i = 0; i < numRows; i++)
	{
		gridMtx2[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			if (lookup2[i][j] < len2)
			{
				gridMtx2[i][j] = gridMtx[i][j];
			}
			else
			{
				gridMtx2[i][j] = -1;
			}
		}
	}
	
	var poss = updatePoss(gridMtx2, initPoss());
	
	for (var cell = 0; cell < numRows * numClms; cell++)
	{
		var row = lookup[cell][0];
		var clm = lookup[cell][1];
		var clrs = [];
		for (var clr = 0; clr < numClrs; clr++)
		{
			if (poss[row][clm][clr])
			{
				var old = gridMtx2[row][clm];
				gridMtx2[row][clm] = clr;			
				if ((document.getElementById("chk1").checked && eqDist(gridMtx2)) || !document.getElementById("chk1").checked)
				{
					clrs.push(clr);
				}
				gridMtx2[row][clm] = old;
			}
		}
		
		if (clrs.length >= 1 && gridMtx2[row][clm] != -1)
		{
			var newClr = clrs[Math.floor(Math.random() * clrs.length)];
			gridMtx2[row][clm] = newClr;
			poss = updatePoss(gridMtx2, poss, cell);
		}
	}
	
	gridMtx2 = randInst(toStr(gridMtx2));
	
	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Shuffle Colors 2<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";

	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function comboMut(keep, list, gridStr)
{
	var gridMtx = copyGrid(gridStr);
	var len1 = gridStr.indexOf("_");
	if (len1 == -1)
	{
		return gridMtx;
	}
	
	var numMvs = parseInt(document.getElementById("comboMutIters").value);
	
	for (var i = 0; i < numMvs; i++)
	{
		var currGrd = gridStr;
		var currLen = currGrd.indexOf("_");
		if (currLen > len1 && sols.indexOf(currGrd) == -1)
		{
			break;
		}
		
		var choice2 = list[Math.floor(Math.random() * list.length)];
		
		if (choice2 == 0)
		{
			gridStr = toStr(chgRdmSub(1, gridStr));
		}
		else if (choice2 == 1)
		{
			gridStr = toStr(clrSwaps(1, gridStr));
		}
		else if (choice2 == 2)
		{
			gridStr = toStr(fixLShapes(1, gridStr));
		}
		else if (choice2 == 3)
		{
			gridStr = toStr(shuffClrs(1, gridStr));
		}
		else if (choice2 == 5)
		{
			gridStr = toStr(shuffClrs2(1, gridStr));
		}
		else if (choice2 == 6)
		{
			gridStr = toStr(incr(1, gridStr));
		}
		else if (choice2 == 7)
		{
			gridStr = toStr(decr(1, gridStr));
		}
		else if (choice2 == 8)
		{
			gridStr = toStr(tryRest(1, gridStr));
		}
		else if (choice2 == 9)
		{
			gridStr = toStr(fixLShapes2(1, gridStr));
		}
		progress[choice]--;
		total[choice]--;
		
		total[choice2]++;
		
		var newLen = gridStr.indexOf("_");
		
		if (newLen >= currLen)
		{
			progress[choice2]++;
		}
		
		if (newLen == -1)
		{
			newLen = numRows * numClms;
		}
		else if (newLen > len1)
		{
			break;
		}
		else if (newLen < currLen)
		{
			gridStr = currGrd;
		}
	}
	
	var gridMtx2 = copyGrid(gridStr);
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Combo<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function swapRows(gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	var completed = [];
	var rwCnt = []; 
	
	var poss = updatePoss(gridMtx, initPoss());
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] == -1)
			{
				var clrs = [];
				for (var k = 0; k < numClrs; k++)
				{
					if (poss[i][j][k])
					{
						clrs.push(k);
					}
				}
				
				if (clrs.length > 0)
				{
					gridMtx[i][j] = clrs[Math.floor(Math.random() * clrs.length)];
					poss = updatePoss(gridMtx, poss);
				}
			}
		}
	}
	
	for (var i = 0; i < numRows; i++)
	{
		rwCnt[i] = 0;
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] != -1)
			{
				rwCnt[i]++;
			}
		}
		
		if (rwCnt[i] == numClms)
		{
			completed[completed.length] = i;
		}
	}
	
	if (completed.length < 2)
	{
		return copyGrid(gridStr);
	}
	
	var newGds = [];
	
	for (var loc1 = 0; loc1 < completed.length; loc1++)
	{
		var val1 = completed[loc1];
		for (var loc2 = loc1 + 1; loc2 < completed.length; loc2++)
		{
			var val2 = completed[loc2];
			var tempMtx = [];
			
			for (var i = 0; i < numRows; i++)
			{
				tempMtx[i] = [];
			}
			
			for (var i = 0; i < numRows; i++)
			{
				if (i != val1 && i != val2)
				{
					for (var j = 0; j < numClms; j++)
					{
						if (lookup2[i][j] < len1)
						{
							tempMtx[i][j] = gridMtx[i][j];
						}
						else
						{
							tempMtx[i][j] = -1;
						}
					}
				}
				else
				{
					for (var j = 0; j < numClms; j++)
					{
						if (lookup2[val1][j] < len1 && lookup2[val2][j] < len1)
						{
							tempMtx[val1][j] = gridMtx[val2][j];
							tempMtx[val2][j] = gridMtx[val1][j];
						}
						else
						{
							tempMtx[val1][j] = -1;
							tempMtx[val2][j] = -1;
						}
					}
				}
			}
			
			var lc = toStr(tempMtx).indexOf("_");
			var tempStr = toStr(tempMtx).substring(0, lc);
			for (var lt = lc; lt < numRows * numClms; lt++)
			{
				tempStr += "_";
			}
			newGds.push(copyGrid(toStr(randInst(tempStr))));
		}
	}

	return newGds;
}
	
function swapClms(gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	var completed = [];
	var clmCnt = []; 
	
	var poss = updatePoss(gridMtx, initPoss());
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] == -1)
			{
				var clrs = [];
				for (var k = 0; k < numClrs; k++)
				{
					if (poss[i][j][k])
					{
						clrs.push(k);
					}
				}
				
				if (clrs.length > 0)
				{
					gridMtx[i][j] = clrs[Math.floor(Math.random() * clrs.length)];
					poss = updatePoss(gridMtx, poss);
				}
			}
		}
	}
		
	for (var j = 0; j < numClms; j++)
	{
		clmCnt[j] = 0;
		
		for (var i = 0; i < numRows; i++)
		{
			if (gridMtx[i][j] != -1)
			{
				clmCnt[j]++;
			}
		}
		
		if (clmCnt[j] == numRows)
		{
			completed[completed.length] = j;
		}
	}
	
	if (completed.length < 2)
	{
		return copyGrid(gridStr);
	}
	
	var newGds = [];
	
	for (var loc1 = 0; loc1 < completed.length; loc1++)
	{
		var val1 = completed[loc1];
		for (var loc2 = loc1 + 1; loc2 < completed.length; loc2++)
		{
			var val2 = completed[loc2];
			var tempMtx = [];
			
			for (var i = 0; i < numRows; i++)
			{
				tempMtx[i] = [];
			}
			
			for (var i = 0; i < gridMtx.length; i++)
			{
				for (var j = 0; j < gridMtx[i].length; j++)
				{
					if (j != val1 && j != val2)
					{
						if (lookup2[i][j] < len1)
						{
							tempMtx[i][j] = gridMtx[i][j];
						}
						else
						{
							tempMtx[i][j] = -1;
						}
					}
					else
					{
						if (lookup2[i][val1] < len1 && lookup2[i][val2] < len1)
						{
							tempMtx[i][val1] = gridMtx[i][val2];
							tempMtx[i][val2] = gridMtx[i][val1];
						}
						else
						{
							tempMtx[i][val1] = -1;
							tempMtx[i][val2] = -1;
						}
					}
				}
			}
			
			var lc = toStr(tempMtx).indexOf("_");
			var tempStr = toStr(tempMtx).substring(0, lc);
			for (var lt = lc; lt < numRows * numClms; lt++)
			{
				tempStr += "_";
			}
			newGds.push(copyGrid(toStr(randInst(tempStr))));
		}
	}

	return newGds;
}
	
function swapClms2(gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	var tempMtx = [];
	var partial = [];
	var last = toStr(gridMtx).indexOf("_");
	
	var poss = updatePoss(gridMtx, initPoss());
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (gridMtx[i][j] == -1)
			{
				var clrs = [];
				for (var k = 0; k < numClrs; k++)
				{
					if (poss[i][j][k])
					{
						clrs.push(k);
					}
				}
				
				if (clrs.length > 0)
				{
					gridMtx[i][j] = clrs[Math.floor(Math.random() * clrs.length)];
					poss = updatePoss(gridMtx, poss);
				}
			}
		}
	}
	
	var lens = [];
	
	for (var j = 0; j < numClms; j++)
	{
		for (var i = 0; i < numRows && gridMtx[i][j] != -1; i++)
		{
			lens[j] = i+1;
		}
	}
	
	for (var j1 = 0; j1 < numClms - 1; j1++)
	{
		if ((lens[j1] == lens[j1+1] && lens[j1] != numRows) || (lens[j1+1] > lens[j1]))
		{
			var arr = [];
			arr.push(j1);
			arr.push(j1+1);
			partial.push(arr);
		}
	}
	
	if (partial.length < 1)
	{
		return copyGrid(gridStr);
	}
	var newGds = [];
	
	var loc = partial[Math.floor(Math.random() * partial.length)];
	var val1 = loc[0];
	var val2 = loc[1];
	var swap = false;
	
	for (var i = 0; i < numRows; i++)
	{
		tempMtx[i] = [];
	}
	
	for (var i = 0; i < numRows; i++)
	{
		for (var j = 0; j < numClms; j++)
		{
			if (j != val1 && j != val2)
			{
				if (lookup2[i][j] < last)
				{
					tempMtx[i][j] = gridMtx[i][j];
				}
				else
				{
					tempMtx[i][j] = -1;
				}
			}
			else
			{
				if (lookup2[i][val1] < last)
				{
					tempMtx[i][val1] = gridMtx[i][val2];
				}
				else
				{
					tempMtx[i][val1] = -1;
				}
				
				if (lookup2[i][val2] < last)
				{
					tempMtx[i][val2] = gridMtx[i][val1];
				}
				else
				{
					tempMtx[i][val2] = -1;
				}
				swap = true;
			}
		}
	}
	
	var lc = toStr(tempMtx).indexOf("_");
	var tempStr = toStr(tempMtx).substring(0, lc);
	for (var lt = lc; lt < numRows * numClms; lt++)
	{
		tempStr += "_";
	}
	newGds.push(copyGrid(toStr(randInst(tempStr))));

	return tempMtx;
}

function transpose(gridStr)
{
	var len1 = gridStr.indexOf("_");	
	var gridMtx = copyGrid(gridStr);
	if (len1 == -1)
	{
		return gridMtx;
	}
	
	if (numClms != numRows)
	{
		return gridMtx;
	}

	var feasib = true;
	for (var i = 0; i < numRows && feasib; i++)
	{
		if (gridMtx[i][numClms-1] != -1 && gridMtx[numRows-1][i] == -1)
		{
			feasib = false;
		}
		
		if (gridMtx[i][numClms-1] == -1 && gridMtx[numRows-1][i] != -1)
		{
			feasib = false;
		}
	}
	
	if (!feasib)
	{
		return gridMtx;
	}
	
	var tempMtx = [];
	
	for (var i = 0; i < numRows; i++)
	{
		tempMtx[i] = [];
		for (var j = 0; j < numClms; j++)
		{
			tempMtx[i][j] = gridMtx[j][i];
		}
	}
	
	var loc = toStr(tempMtx).indexOf("_");
	var tempStr = toStr(tempMtx).substring(0, loc);
	
	for (var i = loc; i < numRows * numClms; i++)
	{
		tempStr += "_";
	}
	
	var tempMtx2 = randInst(tempStr);
	
	return tempMtx2;
}

function tryRest(keep, gridStr)
{
	var gridMtx = copyGrid(gridStr);
	var gridMtx2 = randInst(toStr(initGrid()));
//	dispGrid(gridMtx2);
	
//	var poss2 = updatePoss(gridMtx2, initPoss());

	document.getElementById("output").innerHTML = "Restart<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
	
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function incr(keep, gridStr)
{
    var gridMtx = copyGrid(gridStr);
    var len1 = gridStr.indexOf("_");
    var finished = false;
    var gridMtx2 = copyGrid(gridStr);
	
	finished = false;
	var poss = updatePoss(gridMtx2, initPoss());
	for (var i = len1 - 1; i >= 0 && !finished; i--)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		var size = 0;
		for (var k = 0; k < numClrs; k++)
		{
			if (poss[row][clm][k])
			{
				size++;
			}
		}
		
		if (size == 1)
		{
			gridMtx2[row][clm] = -1;
			poss = updatePoss(gridMtx2, poss);
			continue;
		}
		
		gridMtx2[row][clm] = parseInt(gridMtx2[row][clm]) + 1;
		gridStr2 = toStr(gridMtx2);
		if (gridMtx2[row][clm] < numClrs && !hasRect(gridMtx2) && poss[row][clm][gridMtx2[row][clm]])
		{
			finished = true;
		}
		else
		{
			gridMtx2[row][clm] = -1;
		}
		poss = updatePoss(gridMtx2, poss, i);
	}
	
	var loc = toStr(gridMtx2).indexOf("_");
	gridStr2 = toStr(gridMtx2).substring(0, loc);
	
	for (var i = loc; i < numRows * numClms; i++)
	{
		gridStr2 += "_";
	}
	
	gridMtx2 = randInst(gridStr2);
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Incriment<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
    
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function decr(keep, gridStr)
{
    var gridMtx = copyGrid(gridStr);
    var len1 = gridStr.indexOf("_");
    var finished = false;
    var gridMtx2 = copyGrid(gridStr);
	
	finished = false;
	var poss = updatePoss(gridMtx2, initPoss());
	for (var i = len1 - 1; i >= 0 && !finished; i--)
	{
		var row = lookup[i][0];
		var clm = lookup[i][1];
		poss = updatePoss(gridMtx2, poss);
		var size = 0;
		for (var k = 0; k < numClrs; k++)
		{
			if (poss[row][clm][k])
			{
				size++;
			}
		}
		
		if (size == 1)
		{
			gridMtx2[row][clm] = -1;
			poss = updatePoss(gridMtx2, poss, i);
			continue;
		}
		
		gridMtx2[row][clm] = parseInt(gridMtx2[row][clm]) - 1;
		gridStr2 = toStr(gridMtx2);
		if (gridMtx2[row][clm] >= 0 && !hasRect(gridMtx2) && poss[row][clm][gridMtx2[row][clm]])
		{
			finished = true;
		}
		else
		{
			gridMtx2[row][clm] = -1;
		}
		poss = updatePoss(gridMtx2, poss, i);
	}
	
	var loc = toStr(gridMtx2).indexOf("_");
	gridStr2 = toStr(gridMtx2).substring(0, loc);
	
	for (var i = loc; i < numRows * numClms; i++)
	{
		gridStr2 += "_";
	}
	gridMtx2 = randInst(gridStr2);
//	var poss2 = updatePoss(gridMtx2, initPoss());
	
	document.getElementById("output").innerHTML = "Decriment<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx) + " - " + toStr(gridMtx).indexOf("_") + ", " + (toStr(gridMtx) == toStr(gridMtx2)) + "<br>";
	document.getElementById("output").innerHTML += toStr(gridMtx2) + " - " + toStr(gridMtx2).indexOf("_")
/*	+ " - " + possPairs(gridMtx2, poss2) + " - " + countLs(gridMtx2) + " - " + getDiffs(gridMtx2) + " - " + countPairs(gridMtx2)*/ + "<br>";
    
	if (feas(gridMtx, gridMtx2, keep))
	{
		progress[choice]++;
		total[choice]++;
		return gridMtx2;
	}
	else
	{
		total[choice]++;
		return gridMtx;
	}
}

function feas(gridMtx, gridMtx2, keep=0)
{
	if (keep)
	{
		return true;
	}
	
	if (document.getElementById("chk1").checked && !eqDist(gridMtx2))
	{
		return false;
	}
	
	var gridStr = toStr(gridMtx);
	var gridStr2 = toStr(gridMtx2);
	
//	if (gridMtx != -1)
//	{
//		gridStr = toStr(gridMtx);
//		
//		for (var i = 0; i < sols.length; i++)
//		{
//			if (sols[i].indexOf("_") > gridStr.indexOf("_"))
//			{
//				gridMtx = copyGrid(sols[i]);
//				gridStr = sols[i];
//			}
//		}
//	}
	
	if (gridStr2 == gridStr)
	{
		return false;
	}
	
	var newGds = {};
	
	if (document.getElementById("chk3").checked)
	{
//		dispGrid(gridMtx2);
		var gridMtx4 = transpose(gridStr2);
		var gridStr4 = toStr(gridMtx4);
		if (gridStr4.indexOf("_") > gridStr2.indexOf("_") && !hasRect(gridMtx4))
		{
			gridMtx2 = gridMtx4;
			gridStr2 = gridStr4;
		}
		else if (gridStr4.indexOf("_") == gridStr2.indexOf("_") && !hasRect(gridMtx4))
		{
			var ln = gridStr4.indexOf("_");
			if (ln in newGds)
			{
				newGds[ln].push(gridStr4);
			}
			else
			{
				newGds[ln] = [];
				newGds[ln].push(gridStr4);
			}
		}
	}
	
	if (document.getElementById("chk2").checked)
	{
//		dispGrid(gridMtx2);
		var tmp1 = swapRows(gridStr2);
		
//		dispGrid(gridMtx2);
		Array.prototype.push.apply(tmp1, swapClms(gridStr2));
		
//		dispGrid(gridMtx2);
		tmp1.push(swapClms2(gridStr2));
		
		for (var mtx in tmp1)
		{
			if (hasRect(tmp1[mtx]))
			{
				continue;
			}
			
			var ln = toStr(tmp1[mtx]).indexOf("_");
			if (ln in newGds)
			{
				newGds[ln].push(toStr(tmp1[mtx]));
			}
			else
			{
				newGds[ln] = [];
				newGds[ln].push(toStr(tmp1[mtx]));
			}
		}
	}
	
	var len1 = gridStr.indexOf("_");
	var len2 = gridStr2.indexOf("_");
	
	if (len2 == -1)
	{
		len2 = numRows * numClms;
		return true;
	}
	
	var len = 0;
	if (gridMtx != -1)
	{
		for (var i = 0; i < sols.length; i++)
		{
			var tmp = sols[i].indexOf("_");
			if (tmp > len)
			{
				len = tmp;
			}
		}
	}
	
	if (len == -1)
	{
		len = numRows * numClms;
	}

	if (len2 > len)
	{
		document.getElementById("maxSize").value = 100;
		help[choice]++;
		sols = [];
		sols.push(gridStr2);
//		hist = [];
		
		if (gridMtx != -1)
		{
//			for (var i = len2 - 1; i >= 0.9*len; i--)
//			{
//				var gridStr3 = gridStr2.substr(0, i) + '_' + Array(numRows * numClms - i).join("_") ;
//				hist.push(gridStr3);
//			}
//			hist.push(gridStr);
		}
		hist = dedupe(hist);
		sols = sols.concat(hist);
		for (var i = 0; len2 in newGds && i < newGds[len2].length; i++)
		{
			sols.push(newGds[len2][i]);
		}
		
		if (len2 == numRows * numClms)
		{
			dispMetrics(gridStr2);
			stopTimeout();
		}
		
		sols = dedupe(sols);
		return true;
	}
	else if (len2 == len)
	{
		var poss2 = updatePoss(gridMtx2, initPoss());
		var added  = 0;
		
		sols.push(gridStr2);
		added++;
		
		for (var j = 0; len2 in newGds && j < newGds[len2].length; j++)
		{
			if (sols.indexOf(newGds[len2][j]) == -1)
			{
				sols.push(newGds[len2][j]);
				added++;
			}
		}
		
		sols = dedupe(sols);
		if (added > 0)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	else if (len2 >= len - 5)
	{
		sols.push(gridStr2);
		return false;
	}
	else if (eqDist(gridMtx2) && len2 >= 0.9*len)
	{
		sols.push(gridStr2);
		hist.push(gridStr2);
		sols = dedupe(sols);
		hist = dedupe(hist);
		document.getElementById("finished").innerHTML += len2 + " - " + gridStr2 + "<br>";
		return false;
	}
	else
	{
		return false;
	}
}

function showHideDiv(id)
{
	var val = document.getElementById(id).style.display;
	if (val == "none")
	{
		document.getElementById(id).style.display = "block";
	}
	else
	{
		document.getElementById(id).style.display = "none";
	}
}

function timeout(usrChc) 
{
	var gridStr = getGrid();
	var gridMtx = copyGrid(gridStr);
	if (sols.length == 0)
	{
		sols.push(gridStr);
	}
	var keep = 0;

//	var len1 = gridStr.indexOf("_");
//	if (len1 == -1)
//	{
//		len1 = numRows * numClms;
//		stopTimeout();
//	}
    myVar = setTimeout
	(
		function () 
		{
			var loc = Math.floor(Math.random() * sols.length);
			gridStr = sols[loc];
			gridMtx = copyGrid(sols[loc]);
			len1 = sols[loc].indexOf("_");
			
			if (usrChc == -1)
			{
				var sumN = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
				for (var listL = 0; listL < sumN.length; listL++)
				{
					if (listL == 0)
					{
						sumN[listL] = progress[listL] / total[listL];
					}
					else
					{
						sumN[listL] = sumN[listL-1] + progress[listL] / total[listL];
					}
				}
				
				choice = Math.random() * sumN[sumN.length - 1];
				for (var sumLoc = 0; sumLoc < sumN.length; sumLoc++)
				{
					if (sumN[sumLoc] >= choice)
					{
						choice = sumLoc;
						break;
					}
				}
				
//				if (choice < 5)
//				{
//					choice = 0;
//				}
//				else
//				{
//					choice = 3;
//				}
			}
			else
			{
				choice = usrChc;
			}
			
			if (choice == 0)
			{
				gridMtx = chgRdmSub(keep, gridStr);
			}
			else if (choice == 1)
			{
				gridMtx = clrSwaps(keep, gridStr);
			}
			else if (choice == 2)
			{
				gridMtx = fixLShapes(keep, gridStr);
			}
			else if (choice == 3)
			{
				gridMtx = shuffClrs(keep, gridStr);
			}
			else if (choice == 4)
			{
				var list = [];
				if (document.getElementById("combo0").checked)
				{
					list.push(0);
				}
				if (document.getElementById("combo1").checked)
				{
					list.push(1);
				}
				if (document.getElementById("combo2").checked)
				{
					list.push(2);
				}
				if (document.getElementById("combo3").checked)
				{
					list.push(3);
				}
				if (document.getElementById("combo5").checked)
				{
					list.push(5);
				}
				if (document.getElementById("combo6").checked)
				{
					list.push(6);
				}
				if (document.getElementById("combo7").checked)
				{
					list.push(7);
				}
				if (document.getElementById("combo8").checked)
				{
					list.push(8);
				}
				if (document.getElementById("combo9").checked)
				{
					list.push(9);
				}
				gridMtx = comboMut(keep, list, gridStr);
			}
			else if (choice == 5)
			{
				gridMtx = shuffClrs2(keep, gridStr);
			}
			else if (choice == 6)
			{
				gridMtx = incr(keep, gridStr);
			}
			else if (choice == 7)
			{
				gridMtx = decr(keep, gridStr);
			}
			else if (choice == 8)
			{
				gridMtx = tryRest(keep, gridStr);
			}
			else if (choice == 9)
			{
				gridMtx = fixLShapes2(keep, gridStr);
			}

			gridMtx = randInst(gridMtx);
			if (document.getElementById("grids").style.display != "none")
			{
				showPoss(gridStr); 
			}
			gridStr2 = toStr(gridMtx);
			dispMetrics(gridStr2);
			var out = "<table><tr>";
			out += "<td>Rdm Sub</td>";
			out += "<td>Swaps Color</td>";
			out += "<td>Fix Ls</td>";
			out += "<td>Shuff Clrs</td>";
			out += "<td>ComboMut</td>";
			out += "<td>Shuff Clrs 2</td>";
			out += "<td>Incriment</td>";
			out += "<td>Decriment</td>";
			out += "<td>Restart</td>";
			out += "<td>Fix L Shapes 2</td>";
			out += "</tr>";
			out += "<tr>";
			
			for (var i = 0; i < progress.length; i++)
			{
				out += "<td>" + progress[i] + "/" + total[i] + "</td>";			
			}
			out += "</tr>";
			out += "<tr>";
			for (var i = 0; i < progress.length; i++)
			{
				out += "<td>" + (progress[i] / total[i]).toFixed(4) + "</td>";
			}
			
			out += "</tr>";
			out += "<tr>";
			
			for (var i = 0; i < help.length; i++)
			{
				out += "<td>" + help[i] + "</td>";
			}
			out += "</tr></table>";
			document.getElementById("output").innerHTML += out;
			document.getElementById("output").innerHTML += eqDist(copyGrid(getGrid()));
			
			if (sols.length > parseInt(document.getElementById("maxSize").value))
			{
				document.getElementById("maxSize").value = parseInt(document.getElementById("maxSize").value) + 25;
				if (document.getElementById("maxSize").value > 10000)
				{
					document.getElementById("maxSize").value = 100;
				}
				mnm = -1;
				mnms = [];
				mxlen = -1;
				for (var i = 0; i < sols.length; i++)
				{
					var tmpGrd = copyGrid(sols[i]);
//					var poss = updatePoss(tmpGrd, initPoss());
					var cnt = getDiffs(tmpGrd);
//					var bal = eqDist(tmpGrd);
//					if (bal && hist.indexOf(sols[i]) == -1)
//					{
//						hist.push(sols[i]);
//					}
					var currLen = sols[i].indexOf("_");
					
					if (currLen > mxlen)
					{
						mxlen = currLen;
						mnm = cnt;
						mnms = [];
						mnms.push(i);
					}
					else if (currLen == mxlen)
					{
						if (cnt < mnm)
						{
							mnm = cnt;
							mnms = [];
							mnms.push(i);
						}
						else if (cnt == mnm && mnms.length < 100)
						{
							mnms.push(i);
						}
					}
				}
			
				var plc = Math.floor(Math.random() * 100) + 1;
				var tmp = [];
				for (var i = 0; i < mnms.length; i++)
				{
					tmp.push(sols[mnms[i]]);
				}
				document.getElementById("finished").innerHTML = mnms.length + " - " + mxlen + " - " + mnm + "<br>";
				
				for (var i = 0; i < plc; i++)
				{
					var loc = Math.floor(Math.random() * sols.length);
					
					var currGrid = copyGrid(sols[loc]);
					tmp.push(sols[loc]);
					sols.splice(loc, 1);
				}
				if (tmp.length == 0)
				{
					tmp.push(sols[0]);
				}
				sols = tmp;
				sols = sols.concat(hist);
			}
			
			if (total[0] > 1000)
			{
				for (var i = 0; i < help.length; i++)
				{
					progress[i] = 1;
					total[i] = 1;
				}
			}
			
			var len = getGrid().indexOf("_");
			
			if (len == -1)
			{
				clearTimeout(myVar);
			}
			dispGrid(gridMtx);
			timeout(usrChc);
		}
	, tmo);
}

function stopTimeout() 
{
    clearTimeout(myVar);
}

function restart()
{
	document.getElementById("maxSize").value = 100;
	sols = [];
	hist = [];
	
	for (var i = 0; i < progress.length; i++)
	{
		progress[i] = 1;
		total[i] = 1;
		help[i] = 0;
	}
	var val = document.getElementById("game").value;
	if (val == 0)
	{
		numRows = 10;
		numClms = 10;
		numClrs = 3;
	}
	else if (val == 1)
	{
		numRows = 18;
		numClms = 18;
		numClrs = 4;
	}
	lookup = buildLookup();
	lookup2 = buildLookup2();
	var out = "<table class='grid'>";
	out += "<tr><td class='grid'></td>";
	for (var j = 0; j < numClms; j++)
	{
		out += "<td class='grid'>" + j + "</td>";
	}
	out += "</tr>";
	for (var i = 0; i < numRows; i++)
	{
		out += "<tr><td class='grid'>" + i + "</td>";
		for (var j = 0; j < numClms; j++)
		{
			out += "<td class='grid' id=" + i + "_" + j + " onclick='changecolor(\"" + i + "_" + j + "\"); showPoss(getGrid()); dispMetrics(getGrid())'></td>";
		}
		out += "</tr>";
	}
	document.getElementById("content").innerHTML = out;
	document.getElementById("btn7").click();
//	sols.push(getGrid());
}

function getDist(gridMtx)
{
	var clrs = [];
	var cnt = 0;
	for (var i = 0; i < numClrs; i++)
	{
		clrs[i] = 0;
	}
	
	for (var row = 0; row < numRows; row++)
	{
		for (var clm = 0; clm < numClms; clm++)
		{
			if (gridMtx[row][clm] != -1)
			{
				clrs[gridMtx[row][clm]] ++
				cnt++;
			}
		}
	}
	
	for (var i = 0; i < numClrs; i++)
	{
		clrs[i] /= cnt;
	}
	
	return clrs;
}

function dispMetrics(gridStr)
{
	var out = "<table>";
	var gridMtx = copyGrid(gridStr);
	var poss = updatePoss(gridMtx, initPoss());
	var diffs = getDiffs(gridMtx);
	var pairs = possPairs(gridMtx, poss);
	var pairs2 = countPairs(gridMtx);
	var lshapes = countLs(gridMtx)
	var len = gridStr.indexOf("_");
	var dist = getDist(gridMtx);
	var len2 = 0;
	for (var i = 0; i < sols.length; i++)
	{
		var tmp = sols[i].indexOf("_");
		if (tmp > len2)
		{
			len2 = tmp;
		}
	}
	
	if (len2 == -1)
	{
		len2 = numRows * numClms;
	}
	
	var ratio = (len2 * 100) / (numRows * numClms);
	document.title = "Grid Coloring - " + (ratio).toFixed(0) + " % Complete";
	out += "<tr><td>Cells Occupied:</td>";
	out += "<td>Possible Pairs:</td>";
	out += "<td>Differences: </td>";
	out += "<td>L Shapes: </td>";
	out += "<td>Total Pairs: </td>";
	out += "<td>Solutions</td>";
	out += "<td>Hist</td>";
	out += "<td>Ratios</td>";
	out += "<td>Feasible</td>";
	out += "<td>FSC</td>";
	out += "<td>NSCs</td>";
	out += "</tr>";
	out += "<tr><td>" + len + "</td><td>" + pairs + "</td><td>" + diffs +
		"</td><td>" + lshapes + "</td><td>" + pairs2 + "</td><td>" + sols.length + "</td><td>" + hist.length + "</td>";
//	}

	out += "<td>";
	for (var i = 0; i < dist.length; i++)
	{
		out += (dist[i] * 100).toFixed(0);
		if (i < dist.length - 1)
		{
			out += ", ";
		}
	}
	out += "</td>";
	out += "<td>" + !hasRect(gridMtx) + "</td>";
	out += "<td>" + firstSing(gridMtx, poss) + "</td>";
	out += "<td>" + nonSings(gridMtx, poss) + "</td>";
	out += "</tr></table>";
	document.getElementById("metrics").innerHTML = out;
}

function setRFS()
{
	var checked = document.getElementById("chk4").checked;
	var rfs = [];
	if (checked)
	{
		rfs = [];
		rfs[0] = [0, 0, 0, 0, -1, -1, -1, -1, -1, -1];
		rfs[1] = [0, -1, -1, -1, 0, 0, 0, -1, -1, -1];
		rfs[2] = [-1, 0, -1, -1, 0, -1, -1, 0, 0, -1];
		rfs[3] = [-1, -1, 0, -1, -1, 0, -1, 0, -1, 0];
		rfs[4] = [0, -1, -1, -1, -1, -1, -1, -1, 0, 0];
		rfs[5] = [-1, 0, -1, -1, -1, -1, 0, -1, -1, 0];
		rfs[6] = [-1, -1, 0, -1, -1, -1, 0, -1, 0, -1];
		rfs[7] = [-1, -1, -1, 0, 0, -1, -1, -1, -1, 0];
		rfs[8] = [-1, -1, -1, 0, -1, 0, -1, -1, 0, -1];
		rfs[9] = [-1, -1, -1, 0, -1, -1, 0, 0, -1, -1];
	}
	else
	{
		rfs = -1;
	}
	
	return rfs;
}

function dedupe(arr)
{
    var tmp = [];
    for(var i = 0; i < arr.length; i++)
	{
        if (tmp.indexOf(arr[i]) == -1)
		{
			tmp.push(arr[i]);
        }
    }
	
    return tmp;
}
</script>
</head>
<body>
<input id="oldGrid">
<input type="button" id="btn6" value="Display" onclick="dispGrid(copyGrid(document.getElementById('oldGrid').value)); showPoss(getGrid()); dispMetrics(getGrid()); feas(sols[0], copyGrid(getGrid()), 1); feas(-1, copyGrid(getGrid()), 1);"><br>
<p id="output"></p>
<span onclick=showHideDiv('grids');>Display Grids</span>
<table id="wrapper"><tr id="grids" style="display:none"><td id="content"></td><td id="possGrid"></td></tr>
<tr><td colspan="2"><span onclick=showHideDiv('gamesel');>Game Select Box</span></td></tr>
<tr id="gamesel"><td colspan=2>
<select id="game" onchange="restart()">
  <option value=0>3 Color a 10 by 10</option>
  <option value=1>4 Color a 18 by 18</option>
</select>
</td></tr>
<tr><td colspan="2"><span onclick=showHideDiv('btns1');>Buttons 1</span></td></tr>
<tr id="btns1" style="display:none"><td colspan="2">
<input type="button" id="btn0" onclick="restart()" value="Restart">
<input type="button" id="btn7" onclick="restart();dispGrid(randInst(toStr(initGrid()))); showPoss(getGrid()); dispMetrics(getGrid()); feas(-1, copyGrid(getGrid()), 1)" value="Generate Random">
<input type="button" id="btn2" onclick="getOvlps()" value="Get L Shapes">
<input type="button" id="btn3" onclick="dispGrid(randInst(getGrid())); showPoss(getGrid()); dispMetrics(getGrid())" value="Continue Random">
<input type="button" id="btn5" onclick="showPoss(getGrid()); dispMetrics(getGrid())" value="Show Poss">
<input type="button" id="btn4" onclick="clrGrd()" value="Clear">
<input type="button" id="btn6" onclick="clearTimeout(myVar);timeout(8)" value="Next Coloring">
</td></tr>
<tr><td colspan="2"><span onclick=showHideDiv('btns2');>Buttons 2</span></td></tr>
<tr id="btns2"><td colspan="2">
<input type="button" id="mut0" onclick="clearTimeout(myVar);timeout(0)" value="Change Substring">
<input type="button" id="mut1" onclick="clearTimeout(myVar);timeout(1)" value="Swap Colors">
<input type="button" id="mut2" onclick="clearTimeout(myVar);timeout(2)" value="Fix L Shapes">
<input type="button" id="mut3" onclick="clearTimeout(myVar);timeout(3)" value="Shuffle Colors">
<input type="button" id="mut4" onclick="clearTimeout(myVar);timeout(4)" value="Combination">
<input type="button" id="mut5" onclick="clearTimeout(myVar);timeout(5)" value="Shuffle Colors 2">
<input type="button" id="mut6" onclick="clearTimeout(myVar);timeout(6)" value="Incriment">
<input type="button" id="mut7" onclick="clearTimeout(myVar);timeout(7)" value="Decriment">
<input type="button" id="mut8" onclick="clearTimeout(myVar);timeout(8)" value="Try Restart">
<input type="button" id="mut9" onclick="clearTimeout(myVar);timeout(9)" value="Fix L Shapes 2"><br>
<input type="button" id="btn9" onclick="clearTimeout(myVar);timeout(-1);" value="Repeat Random Change">
<input type="button" id="btn10" onclick="clearTimeout(myVar);" value="Stop Timeout"><br>
<label>Iterations for Combo Mutation</label><select id="comboMutIters">
  <option value=1>1</option>
  <option value=2>2</option>
  <option value=5>5</option>
  <option value=10 selected>10</option>
  <option value=25>25</option>
  <option value=50>50</option>
  <option value=100>100</option>
</select>
</td></tr>
<tr><td colspan="2"><span onclick=showHideDiv('boxes1');>Checkboxes 1</span></td></tr>
<tr id="boxes1" style="display:none"><td colspan="2">
<input type="checkbox" id="combo0" checked><label>Change Substring</label><br>
<input type="checkbox" id="combo1" checked><label>Swap Colors</label><br>
<input type="checkbox" id="combo2" checked><label>Fix L Shapes</label><br>
<input type="checkbox" id="combo3" checked><label>Shuffle Colors</label><br>
<input type="checkbox" id="combo5" checked><label>Shuffle Colors 2</label><br>
<input type="checkbox" id="combo6" checked><label>Incriment</label><br>
<input type="checkbox" id="combo7" checked><label>Decriment</label><br>
<input type="checkbox" id="combo8" checked><label>Try Restart</label><br>
<input type="checkbox" id="combo9" checked><label>Fix L Shapes 2</label><br>
</td></tr>
<tr><td colspan="2"><span onclick=showHideDiv('boxes2');>Checkboxes 2</span></td></tr>
<tr id="boxes2" style="display:none"><td>
<input type="checkbox" id="chk1"><label>Equal Distribution? </label><br>
<input type="checkbox" id="chk2" checked><label>Allow for row and column swaps?</label><br>
<input type="checkbox" id="chk3" checked><label>Allow for transpose?</label><br>
<input type="checkbox" id="chk4"><label>Use Rectangle Free Sets</label><br>
</td></tr>
<tr><td span=2 id="metrics"></td></tr></table>
<input id="maxSize" value="100">
<p id="finished"></p>
<table id="finGds"></table>
<!--<canvas name="myCanvas"  id="myCanvas" width=550 height=550 style="border:1px solid #000000;">your browser does not support the canvas tag</canvas>-->
<script type="text/javascript">
var progress = [];
var total = [];
var help = [];
/*var rfs = [];
rfs[0] = [0, 0, 0, 0, -1, -1, -1, -1, -1, -1];
rfs[1] = [0, -1, -1, -1, 0, 0, 0, -1, -1, -1];
rfs[2] = [-1, 0, -1, -1, 0, -1, -1, 0, 0, -1];
rfs[3] = [-1, -1, 0, -1, -1, 0, -1, 0, -1, 0];
rfs[4] = [0, -1, -1, -1, -1, -1, -1, -1, 0, 0];
rfs[5] = [-1, 0, -1, -1, -1, -1, 0, -1, -1, 0];
rfs[6] = [-1, -1, 0, -1, -1, -1, 0, -1, 0, -1];
rfs[7] = [-1, -1, -1, 0, 0, -1, -1, -1, -1, 0];
rfs[8] = [-1, -1, -1, 0, -1, 0, -1, -1, 0, -1];
rfs[9] = [-1, -1, -1, 0, -1, -1, 0, 0, -1, -1];*/

myVar = setTimeout(function(){}, 10000000000);
clearTimeout(myVar);
progress[0] = 1;
progress[1] = 1;
progress[2] = 1;
progress[3] = 1;
progress[4] = 1;
progress[5] = 1;
progress[6] = 1;
progress[7] = 1;
progress[8] = 1;
progress[9] = 1;

total[0] = 1;
total[1] = 1;
total[2] = 1;
total[3] = 1;
total[4] = 1;
total[5] = 1;
total[6] = 1;
total[7] = 1;
total[8] = 1;
total[9] = 1;

help[0] = 0;
help[1] = 0;
help[2] = 0;
help[3] = 0;
help[4] = 0;
help[5] = 0;
help[6] = 0;
help[7] = 0;
help[8] = 0;
help[9] = 0;
sols = [];
hist = [];
//fails = [];
//var M_VAL = 50000;
var choice = -1;
var numRows = 10;
var numClms = 10;
var numClrs = 3;
var lookup = buildLookup();
var lookup2 = buildLookup2();
var best = [];
var tmo = 5 * numRows * numClms;
var out = "<table class='grid'>";
out += "<tr><td class='grid'></td>";
for (var j = 0; j < numClms; j++)
{
	out += "<td class='grid'>" + j + "</td>";
}
out += "</tr>";
for (var i = 0; i < numRows; i++)
{
	out += "<tr><td class='grid'>" + i + "</td>";
	for (var j = 0; j < numClms; j++)
	{
		out += "<td class='grid' id=" + i + "_" + j + " onclick='changecolor(\"" + i + "_" + j + "\"); showPoss(getGrid()); dispMetrics(getGrid())'></td>";
	}
	out += "</tr>";
}
document.getElementById("content").innerHTML = out;
document.getElementById("btn7").click();

/*
1111223323 (1, 2, 3, 4)(5, 6, 9)(7, 8, 10)
1223111332 (1, 5, 6, 7)(2, 3, 10)(4, 8, 9)
3123122113 (2, 5, 8, 9)(3, 6, 7)(1, 4, 10)
3212213131 (3, 6, 8, 10)()()
1233323211 (1, 9, 10)()()
3122331221 (2, 7, 10)()()
2312321312 (3, 7, 9)()()
2231132321 (4, 5, 10)()()
3331212212 (4, 6, 9)()()
2321231133 (4, 7, 8)()()

1	1	1	2	2	3	3	2	3	1
1	2	2	1	1	3	2	3	1	3
3	1	2	1	2	1	3	1	2	3
3	2	1	2	1	1	1	3	3	2
1	2	3	3	2	2	1	1	3	3
3	1	2	3	3	2	1	2	1	2
2	3	1	3	2	3	2	1	1	2
2	2	3	1	3	3	1	2	2	1
3	3	3	2	1	2	2	1	2	1
2	3	2	2	3	1	3	3	1	1


0000120102121101020122001201201121211210210122202121221100222022221010010010210012101002121110000122
022210110210222020001002010021111011122202022210102111101122022210102120101210121221222000101102002_
00002102012121010101210022011012112221201201122022121221001110112120200200202200112020011122200001__

1111______
1___111___
_1__1__11_
__1__1_1_1
1_______11
_1____1__1
__1___1_1_
___11____1
___1_1__1_
___1__11__
*/
//var clqs = [];
//formGraph();
</script>
</body>
</html>
