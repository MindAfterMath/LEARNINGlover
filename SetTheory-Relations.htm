<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta name="author" content="AfterMath" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
SetTheory:Relations<script type="text/javascript">
function antiSymm(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		for (var j = i + 1; j < rel.length && text == ""; j++)
		{	
			if (rel[i].x1.value == rel[j].x2.value && rel[i].x2.value == rel[j].x1.value && rel[i].x1.value != rel[i].x2.value)
			{
				text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so this relation is not anti-symmetric. <br>";
			}
		}
	}

	return text;
}

function cartProd(set1, set2)
{
	var set3 = new Array()
	var i, j;

	for (i = 0; i < set1.length; i++)
	{
		for (j = 0; j < set2.length; j++)
		{
			set3[set3.length] = new Object();
			set3[set3.length - 1].x1 = new Object();
			set3[set3.length - 1].x2 = new Object();
			set3[set3.length - 1].x1.value = set1[i];
			set3[set3.length - 1].x2.value = set2[j];
		}
	}

	return set3;
}

function clearRect()
{
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");

	ctx.fillStyle = "#FFFFFF";
	ctx.fillRect(0, 0, c.width, c.height);
	ctx.fill();

	return;
}

function compress(rel)
{
	var rel2 = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search2(rel2, rel[i].x1.value, rel[i].x2.value))
		{
			rel2[rel2.length] = new Object();
			rel2[rel2.length - 1].x1 = new Object();
			rel2[rel2.length - 1].x2 = new Object();
			rel2[rel2.length - 1].x1.value = rel[i].x1.value;
			rel2[rel2.length - 1].x1.xLoc = rel[i].x1.xLoc;
			rel2[rel2.length - 1].x1.yLoc = rel[i].x1.yLoc;
			rel2[rel2.length - 1].x2.value = rel[i].x2.value;
			rel2[rel2.length - 1].x2.xLoc = rel[i].x2.xLoc;
			rel2[rel2.length - 1].x2.yLoc = rel[i].x2.yLoc;
		}
	}

	return rel2;
}

function display(rel)
{
	var i, text = "";
	text += "{";
	for (i = 0; i < rel.length; i++)
	{
		if (i < rel.length - 1)
			text += "(" + rel[i].x1.value + ", " + rel[i].x2.value + "), ";
		else
			text += "(" + rel[i].x1.value + ", " + rel[i].x2.value + ")";
	}
	text += "}";

	return text;
}

function domain(rel)
{
	var dom = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search0(dom, rel[i].x1.value))
			dom[dom.length] = rel[i].x1.value;
	}

	return dom;
}

function drawLines(rel)
{
	var i, j;
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");

	for (i = 0; i < rel.length; i++)
	{
		ctx.strokeStyle = "#FF00FF";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(rel[i].x1.xLoc + 10, rel[i].x1.yLoc);
		ctx.lineTo(rel[i].x2.xLoc - 10, rel[i].x2.yLoc);
		ctx.stroke();
	}
}

function drawPts(rel)
{
	var i, j;
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	ctx.fillStyle = "#000000";

	for (i = 0; i < rel.length; i++)
	{
		if (rel[i].x1.value != 0)
			ctx.fillText(rel[i].x1.value, rel[i].x1.xLoc-3*(Math.floor(Math.log(rel[i].x1.value)/Math.log(10))+1), rel[i].x1.yLoc+4);
		else
			ctx.fillText(rel[i].x1.value, rel[i].x1.xLoc-3*(Math.floor(Math.log(1)/Math.log(10))+1), rel[i].x1.yLoc+4);

		if (rel[i].x2.value != 0)
			ctx.fillText(rel[i].x2.value, rel[i].x2.xLoc-3*(Math.floor(Math.log(rel[i].x2.value)/Math.log(10))+1), rel[i].x2.yLoc+4);
		else
			ctx.fillText(rel[i].x2.value, rel[i].x2.xLoc-3*(Math.floor(Math.log(1)/Math.log(10))+1), rel[i].x2.yLoc+4);

	}
}

function equivrel(rel, univ)
{
	var ans = false, text = "";
	var symmAns = symm(rel);
	var reflAns = refl(rel, univ);
	var transAns = trans(rel);

	if (symmAns == "" && reflAns == "" && transAns == "")
		text += "The relation is an equivalence relation<br>";
	else 
	{
		if (symmAns)
			text += symmAns + "The relation is not symmtric<br>";
		if (reflAns)
			text += reflAns + "The relation is not reflexive<br>";
		if (transAns)
			text += transAns + "The relation is not transitive<br>";
	}

	return text;
}

function generate1(n)
{
	var A = new Array(n);
	var i, next;
	for (i = 0; i < n; i++)
	{
		next = Math.floor((Math.random())*100);
		if (!search0(A, next))
			A[i] = next;
		else
			i--;
	}

	return A;
}

function generate2(n, univ)
{
	var A = new Array(n);
	var i, next;
	for (i = 0; i < n; i++)
	{
		next = Math.floor((Math.random())*univ.length);
		if (!search0(A, univ[next]))
		{
			A[i] = univ[next];
			remove(univ, next);
		}
		else
			i--;
	}

	return A;
}

function init(set1, k1)
{
	set1 = generate1(k1);
	var universe;
	var i, j;
	var ans = new Array();
	var text = "";

	ans[0] = set1;
	universe = cartProd(set1, set1);
	universe = sort(universe);
	universe = setLocs(universe);
	drawPts(universe);
	ans[1] = universe;
	var k3 = Math.floor(Math.random()*universe.length);
	if (k3 > 25)
		k3 = 25;
	var rel = generate2(k3, universe);
	rel = sort(rel);
	text += "<p>rel = " + display(rel) + "</p>";
	drawLines(rel);
	ans[2] = rel;

	document.getElementById("list").innerHTML += text;
	return ans;
}

function isFunct(rel)
{
	var text = "";
	var dom = new Array();
	for (var i = 0; i < rel.length && text == ""; i++)
	{
		if (!search0(dom, rel[i].x1.value))
			dom[dom.length] = rel[i].x1.value;
		else
		{
			text += "The element " + rel[i].x1.value + " is assigned to more than one element. <br>";
		}
	}

	if (text == "")
		text += "This relation is a function.<br>";
	else
		text += "This relation is not a function.<br>";

	document.getElementById("output").innerHTML = text;
	return text;
}

function makeAntiSymm(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var text = "";
	for (var i = 0; i < rel.length; i++)
	{
		for (var j = i + 1; j < rel.length; j++)
		{	
			if (rel[i].x1.value == rel[j].x2.value && rel[i].x2.value == rel[j].x1.value && rel[i].x1.value != rel[i].x2.value)
			{
				var loc = Math.floor(Math.random()*2);
				if (loc == 0)
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so one must be removed. <br>";
						text += "removing element (" + rel[i].x1.value + ", " + rel[i].x2.value + ")" + "<br>";
					}
					rel = remove(rel, i);
					i--;
					j = rel.length;
				}
				else
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so one must be removed. <br>";
						text += "removing element (" + rel[j].x1.value + ", " + rel[j].x2.value + ")" + "<br>";
					}
					rel = remove(rel, j);
					j--;
				}
			}
		}
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeFunct(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var i, j;
	var text = "";
	for (i = 0; i < rel.length; i++)
	{
		for (j = i+1; j < rel.length; j++)
		{
			if (rel[i].x1.value == rel[j].x1.value)
			{
				var loc = Math.floor(Math.random()*2);
				if (loc == 0)
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") have the same domain element, so one must be removed. <br>";
						text += "removing element (" + rel[i].x1.value + ", " + rel[i].x2.value + ")" + "<br>";
					}
					rel = remove(rel, i);
					i--;
					j = rel.length;
				}
				else
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") have the same domain element, so one must be removed. <br>";
						text += "removing element (" + rel[j].x1.value + ", " + rel[j].x2.value + ")" + "<br>";
					}
					rel = remove(rel, j);
					j--;
				}
			}
		}
	}
	
	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeRefl(rel, univ)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = univ.length;
	var text = "";

	for (var i = 0; i < k; i++)
	{
		if (univ[i].x1.value == univ[i].x2.value)
		{
			if (document.getElementById("show").checked)
				text += "To ensure reflexitivity, adding element (" + univ[i].x1.value + ", " + univ[i].x2.value + ")<br>";
			var temp0 = univ[i];
			rel[rel.length] = new Object();
			rel[rel.length - 1] = temp0;
			rel[rel.length - 1] = temp0;
		}
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;

	return rel;
}

function makeSymm(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = rel.length;
	var text = "";

	for (var i = 0; i < k; i++)
	{
		if (document.getElementById("show").checked)
		{
			text += "The element (" + rel[i].x1.value + ", " + rel[i].x2.value + ") is a member of this relation. ";
			text += "To ensure symmetry, adding the element (" + rel[i].x2.value + ", " + rel[i].x1.value + ")<br>";
		}
		rel[rel.length] = new Object();
		rel[rel.length - 1].x1 = new Object();
		rel[rel.length - 1].x2 = new Object();
		rel[rel.length - 1].x1.value = rel[i].x2.value;
		rel[rel.length - 1].x1.xLoc = rel[i].x1.xLoc;
		rel[rel.length - 1].x1.yLoc = rel[i].x2.yLoc;
		rel[rel.length - 1].x2.value = rel[i].x1.value;
		rel[rel.length - 1].x2.xLoc = rel[i].x2.xLoc;
		rel[rel.length - 1].x2.yLoc = rel[i].x1.yLoc;
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeTrans(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = rel.length;
	var text = "";
	var contin = true;

	while (contin)
	{
		contin = false;
//		k = rel.length;
		for (var i = 0; i < rel.length; i++)
		{
			for (var j = i+1; j < rel.length; j++)
			{
				if (rel[i].x1.value == rel[j].x2.value && !search2(rel, rel[j].x1.value, rel[i].x2.value))		//(a, b) and (c, a)
				{
					contin = true;
					if (document.getElementById("show").checked)
						text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") implies (" + rel[j].x1.value + ", " + rel[i].x2.value + ")<br>";
					rel[rel.length] = new Object();
					rel[rel.length - 1].x1 = new Object();
					rel[rel.length - 1].x2 = new Object();
					rel[rel.length - 1].x1.value = rel[j].x1.value;
					rel[rel.length - 1].x1.xLoc = rel[j].x1.xLoc;
					rel[rel.length - 1].x1.yLoc = rel[j].x1.yLoc;
					rel[rel.length - 1].x2.value = rel[i].x2.value;
					rel[rel.length - 1].x2.xLoc = rel[i].x2.xLoc;
					rel[rel.length - 1].x2.yLoc = rel[i].x2.yLoc;					
				}
				else if (rel[i].x2.value == rel[j].x1.value && !search2(rel, rel[i].x1.value, rel[j].x2.value))	//(a, b) and (b, c)
				{
					contin = true;
					if (document.getElementById("show").checked)
						text += "Elements (" + rel[j].x1.value + ", " + rel[j].x2.value + ") and (" + rel[i].x1.value + ", " + rel[i].x2.value + ") implies (" + rel[i].x1.value + ", " + rel[j].x2.value + ")<br>";
					rel[rel.length] = new Object();
					rel[rel.length - 1].x1 = new Object();
					rel[rel.length - 1].x2 = new Object();
					rel[rel.length - 1].x1.value = rel[i].x1.value;
					rel[rel.length - 1].x1.xLoc = rel[i].x1.xLoc;
					rel[rel.length - 1].x1.yLoc = rel[i].x1.yLoc;
					rel[rel.length - 1].x2.value = rel[j].x2.value;
					rel[rel.length - 1].x2.xLoc = rel[j].x2.xLoc;
					rel[rel.length - 1].x2.yLoc = rel[j].x2.yLoc;
				}
			}
		}
	}

	rel = compress(rel);
	rel = sort(rel);
	document.getElementById("output").innerHTML += text;

	return rel;
}

function operate(rel, univ)
{
 	if (document.getElementById("alg").value == 1)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeSymm(rel);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 2)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeRefl(rel, univ);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 3)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeTrans(rel);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 4)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeAntiSymm(rel);
		drawPts(univ);
		drawLines(rel);
	}
	else if (document.getElementById("alg").value == 5)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
		rel = makeFunct(rel);
		drawPts(univ);
		drawLines(rel);
	}

	return rel;
}

function poset(rel, univ)
{
	var ans = false, text = "";
	var antiSymmAns = antiSymm(rel);
	var reflAns = refl(rel, univ);
	var transAns = trans(rel);

	if (antiSymmAns == "" && reflAns == "" && transAns == "")
		text += "The relation is a Partial Order. <br>";
	else 
	{
		if (antiSymmAns != "")
			text += antiSymmAns + "The relation is not anti-symmtric<br>";
		if (reflAns != "")
			text += reflAns + "The relation is not reflexive<br>";
		if (transAns)
			text += transAns + "The relation is not transitive<br>";
	}

	return text;
}

function range(rel)
{
	var ran = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search0(ran, rel[i].x2.value))
			ran[ran.length] = rel[i].x2.value;
	}

	return ran;
}

function refl(rel, univ)
{
	var text = "";

	for (var i = 0; i < univ.length && text == ""; i++)
	{
		if ((univ[i].x1.value == univ[i].x2.value) && !search2(rel, univ[i].x1.value, univ[i].x2.value))
			text += "The element (" + univ[i].x1.value + ", " + univ[i].x2.value + ") does not belong to the relation.<br>";
	}

	return text;
}

function remove(set, loc)
{
	set[loc] = set[set.length-1];
	set.length--;
	
	return set;
}

function retreive(set, start, finish)
{
	var i;
	var ans = new Array();
	for (i = start; i < finish; i++)
		ans[ans.length] = set[i];

	return ans;
}

function search0(set, elmnt)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i] == elmnt)
			ans = true;

	return ans;
}

function search1(set, elmnt)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i].x1.value == elmnt)
			ans = true;

	return ans;
}

function search2(set, elmnt1, elmnt2)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i].x1.value == elmnt1 && set[i].x2.value == elmnt2)
			ans = true;

	return ans;
}

function setLocs(rel)
{
	var c = document.getElementById("myCanvas");
	var dom = domain(rel);
	var ran = range(rel);
	var set = union(dom, ran);
	var i, j, temp;

	for (i = 0; i < set.length; i++)
		for (j = i+1; j < set.length; j++)
		{
			if (set[i] > set[j])
			{
				temp = set[i];
				set[i] = set[j];
				set[j] = temp;
			}
		}

	for (i = 0; i < set.length; i++)
	{
		for (j = 0; j < rel.length; j++)
		{
			if (rel[j].x1.value == set[i])
			{
				rel[j].x1.yLoc = i*25 + 25;
				rel[j].x1.xLoc = (0 + c.width) / 5;
			}
			if (rel[j].x2.value == set[i])
			{
				rel[j].x2.yLoc = i*25 + 25;
				rel[j].x2.xLoc = 4*(0 + c.width) / 5;
			}
		}
	}
	return rel;
}

function sort(rel)
{
	var i, j;
	var temp;
	count = 0;
	for (i = 0; i < rel.length; i++)
		for (j = i + 1; j < rel.length; j++)
		{
			if (rel[i].x1.value >  rel[j].x1.value || (rel[i].x1.value == rel[j].x1.value && rel[i].x2.value >  rel[j].x2.value))
			{
				temp = rel[i];
				rel[i] = rel[j];
				rel[j] = temp;
			}
			count++;
		}

	return rel;
}

function symm(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		if (!search2(rel, rel[i].x2.value, rel[i].x1.value))
			text += "The element (" + rel[i].x1.value + ", " + rel[i].x2.value + ") is in the relation, but (" + rel[i].x2.value + ", " + rel[i].x1.value + ") is not. <br>"
	}

	return text;
}

function total(rel, univ)
{
	var text = "";
	var set1 = domain(univ);
	var set2 = range(univ);

	for (var i = 0; i < set1.length && text == ""; i++)
	{
		for (var j = 0; j < set2.length && text == ""; j++)
		{
			if (!search2(rel, set1[i], set2[j]) && !search2(rel, set2[j], set1[i]))
				text += "Elements " + set1[i] + " and " + set2[j] + " are not related. <br>";
		}
	}
	text += poset(rel, univ);

	return text;
}

function trans(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		for (var j = i + 1; j < rel.length && text == ""; j++)
		{
			if (rel[i].x1.value == rel[j].x2.value)
			{
				if (!search2(rel, rel[j].x1.value, rel[i].x2.value))
					text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") belong to this relation, but (" + rel[j].x1.value + ", " + rel[i].x2.value + ") does not. <br>";
			}
			else if (rel[i].x2.value == rel[j].x1.value)
			{
				if (!search2(rel, rel[i].x1.value, rel[j].x2.value))
					text += "Elements (" + rel[j].x1.value + ", " + rel[j].x2.value + ") and (" + rel[i].x1.value + ", " + rel[i].x2.value + ") belong to this relation, but (" + rel[i].x1.value + ", " + rel[j].x2.value + ") does not<br>";
			}
		}
	}

	return text;
}

function union(set1, set2)
{
	var set3 = new Array();
	var i;

	for (i = 0; i < set1.length; i++)
		set3[i] = set1[i];

	for (i = 0; i < set2.length; i++)
	{
		if (!search0(set3, set2[i]))
			set3[set3.length] = set2[i];
	}

	return set3;
}
</script><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta name="author" content="AfterMath" /><link rel="stylesheet" type="text/css" href="style.css" media="screen" /><meta name="keywords" content=" anti-symmetric, antisymmetric, cross product, equivalence relation, examples, function, JavaScript, learn, learning, math, mathematics, order, ordered, ordered paid, pair, partial order, partial order set, poset, qb rating, random, rating, reflexive, relation, relationship, script, set, set theory, symmetric, theory, total order, transitive" /> 
<meta name="description" content="This page contains a script I've written to help understand relations in set theory." />
<title> at LEARNINGlover.com</title>
<script type="text/javascript">
function antiSymm(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		for (var j = i + 1; j < rel.length && text == ""; j++)
		{	
			if (rel[i].x1.value == rel[j].x2.value && rel[i].x2.value == rel[j].x1.value && rel[i].x1.value != rel[i].x2.value)
			{
				text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so this relation is not anti-symmetric. <br>";
			}
		}
	}

	return text;
}

function cartProd(set1, set2)
{
	var set3 = new Array()
	var i, j;

	for (i = 0; i < set1.length; i++)
	{
		for (j = 0; j < set2.length; j++)
		{
			set3[set3.length] = new Object();
			set3[set3.length - 1].x1 = new Object();
			set3[set3.length - 1].x2 = new Object();
			set3[set3.length - 1].x1.value = set1[i];
			set3[set3.length - 1].x2.value = set2[j];
		}
	}

	return set3;
}

function clearRect()
{
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");

	ctx.fillStyle = "#FFFFFF";
	ctx.fillRect(0, 0, c.width, c.height);
	ctx.fill();

	return;
}

function compress(rel)
{
	var rel2 = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search2(rel2, rel[i].x1.value, rel[i].x2.value))
		{
			rel2[rel2.length] = new Object();
			rel2[rel2.length - 1].x1 = new Object();
			rel2[rel2.length - 1].x2 = new Object();
			rel2[rel2.length - 1].x1.value = rel[i].x1.value;
			rel2[rel2.length - 1].x1.xLoc = rel[i].x1.xLoc;
			rel2[rel2.length - 1].x1.yLoc = rel[i].x1.yLoc;
			rel2[rel2.length - 1].x2.value = rel[i].x2.value;
			rel2[rel2.length - 1].x2.xLoc = rel[i].x2.xLoc;
			rel2[rel2.length - 1].x2.yLoc = rel[i].x2.yLoc;
		}
	}

	return rel2;
}

function display(rel)
{
	var i, text = "";
	text += "{";
	for (i = 0; i < rel.length; i++)
	{
		if (i < rel.length - 1)
			text += "(" + rel[i].x1.value + ", " + rel[i].x2.value + "), ";
		else
			text += "(" + rel[i].x1.value + ", " + rel[i].x2.value + ")";
	}
	text += "}";

	return text;
}

function domain(rel)
{
	var dom = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search0(dom, rel[i].x1.value))
			dom[dom.length] = rel[i].x1.value;
	}

	return dom;
}

function drawLines(rel)
{
	var i, j;
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");

	for (i = 0; i < rel.length; i++)
	{
		ctx.strokeStyle = "#FF00FF";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(rel[i].x1.xLoc + 10, rel[i].x1.yLoc);
		ctx.lineTo(rel[i].x2.xLoc - 10, rel[i].x2.yLoc);
		ctx.stroke();
	}
}

function drawPts(rel)
{
	var i, j;
	var c = document.getElementById("myCanvas");
	var ctx = c.getContext("2d");
	ctx.fillStyle = "#000000";

	for (i = 0; i < rel.length; i++)
	{
		if (rel[i].x1.value != 0)
			ctx.fillText(rel[i].x1.value, rel[i].x1.xLoc-3*(Math.floor(Math.log(rel[i].x1.value)/Math.log(10))+1), rel[i].x1.yLoc+4);
		else
			ctx.fillText(rel[i].x1.value, rel[i].x1.xLoc-3*(Math.floor(Math.log(1)/Math.log(10))+1), rel[i].x1.yLoc+4);

		if (rel[i].x2.value != 0)
			ctx.fillText(rel[i].x2.value, rel[i].x2.xLoc-3*(Math.floor(Math.log(rel[i].x2.value)/Math.log(10))+1), rel[i].x2.yLoc+4);
		else
			ctx.fillText(rel[i].x2.value, rel[i].x2.xLoc-3*(Math.floor(Math.log(1)/Math.log(10))+1), rel[i].x2.yLoc+4);

	}
}

function equivrel(rel, univ)
{
	var ans = false, text = "";
	var symmAns = symm(rel);
	var reflAns = refl(rel, univ);
	var transAns = trans(rel);

	if (symmAns == "" && reflAns == "" && transAns == "")
		text += "The relation is an equivalence relation<br>";
	else 
	{
		if (symmAns)
			text += symmAns + "The relation is not symmtric<br>";
		if (reflAns)
			text += reflAns + "The relation is not reflexive<br>";
		if (transAns)
			text += transAns + "The relation is not transitive<br>";
	}

	return text;
}

function generate1(n)
{
	var A = new Array(n);
	var i, next;
	for (i = 0; i < n; i++)
	{
		next = Math.floor((Math.random())*100);
		if (!search0(A, next))
			A[i] = next;
		else
			i--;
	}

	return A;
}

function generate2(n, univ)
{
	var A = new Array(n);
	var i, next;
	for (i = 0; i < n; i++)
	{
		next = Math.floor((Math.random())*univ.length);
		if (!search0(A, univ[next]))
		{
			A[i] = univ[next];
			remove(univ, next);
		}
		else
			i--;
	}

	return A;
}

function init(set1, k1)
{
	set1 = generate1(k1);
	var universe;
	var i, j;
	var ans = new Array();
	var text = "";

	ans[0] = set1;
	universe = cartProd(set1, set1);
	universe = sort(universe);
	universe = setLocs(universe);
	drawPts(universe);
	ans[1] = universe;
	var k3 = Math.floor(Math.random()*universe.length);
	if (k3 > 25)
		k3 = 25;
	var rel = generate2(k3, universe);
	rel = sort(rel);
	text += "<p>rel = " + display(rel) + "</p>";
	drawLines(rel);
	ans[2] = rel;

	document.getElementById("list").innerHTML += text;
	return ans;
}

function isFunct(rel)
{
	var text = "";
	var dom = new Array();
	for (var i = 0; i < rel.length && text == ""; i++)
	{
		if (!search0(dom, rel[i].x1.value))
			dom[dom.length] = rel[i].x1.value;
		else
		{
			text += "The element " + rel[i].x1.value + " is assigned to more than one element. <br>";
		}
	}

	if (text == "")
		text += "This relation is a function.<br>";
	else
		text += "This relation is not a function.<br>";

	document.getElementById("output").innerHTML = text;
	return text;
}

function makeAntiSymm(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var text = "";
	for (var i = 0; i < rel.length; i++)
	{
		for (var j = i + 1; j < rel.length; j++)
		{	
			if (rel[i].x1.value == rel[j].x2.value && rel[i].x2.value == rel[j].x1.value && rel[i].x1.value != rel[i].x2.value)
			{
				var loc = Math.floor(Math.random()*2);
				if (loc == 0)
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so one must be removed. <br>";
						text += "removing element (" + rel[i].x1.value + ", " + rel[i].x2.value + ")" + "<br>";
					}
					rel = remove(rel, i);
					i--;
					j = rel.length;
				}
				else
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") relate to one another, so one must be removed. <br>";
						text += "removing element (" + rel[j].x1.value + ", " + rel[j].x2.value + ")" + "<br>";
					}
					rel = remove(rel, j);
					j--;
				}
			}
		}
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeFunct(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var i, j;
	var text = "";
	for (i = 0; i < rel.length; i++)
	{
		for (j = i+1; j < rel.length; j++)
		{
			if (rel[i].x1.value == rel[j].x1.value)
			{
				var loc = Math.floor(Math.random()*2);
				if (loc == 0)
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") have the same domain element, so one must be removed. <br>";
						text += "removing element (" + rel[i].x1.value + ", " + rel[i].x2.value + ")" + "<br>";
					}
					rel = remove(rel, i);
					i--;
					j = rel.length;
				}
				else
				{
					if (document.getElementById("show").checked)
					{
						text += "elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") have the same domain element, so one must be removed. <br>";
						text += "removing element (" + rel[j].x1.value + ", " + rel[j].x2.value + ")" + "<br>";
					}
					rel = remove(rel, j);
					j--;
				}
			}
		}
	}
	
	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeRefl(rel, univ)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = univ.length;
	var text = "";

	for (var i = 0; i < k; i++)
	{
		if (univ[i].x1.value == univ[i].x2.value)
		{
			if (document.getElementById("show").checked)
				text += "To ensure reflexitivity, adding element (" + univ[i].x1.value + ", " + univ[i].x2.value + ")<br>";
			var temp0 = univ[i];
			rel[rel.length] = new Object();
			rel[rel.length - 1] = temp0;
			rel[rel.length - 1] = temp0;
		}
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;

	return rel;
}

function makeSymm(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = rel.length;
	var text = "";

	for (var i = 0; i < k; i++)
	{
		if (document.getElementById("show").checked)
		{
			text += "The element (" + rel[i].x1.value + ", " + rel[i].x2.value + ") is a member of this relation. ";
			text += "To ensure symmetry, adding the element (" + rel[i].x2.value + ", " + rel[i].x1.value + ")<br>";
		}
		rel[rel.length] = new Object();
		rel[rel.length - 1].x1 = new Object();
		rel[rel.length - 1].x2 = new Object();
		rel[rel.length - 1].x1.value = rel[i].x2.value;
		rel[rel.length - 1].x1.xLoc = rel[i].x1.xLoc;
		rel[rel.length - 1].x1.yLoc = rel[i].x2.yLoc;
		rel[rel.length - 1].x2.value = rel[i].x1.value;
		rel[rel.length - 1].x2.xLoc = rel[i].x2.xLoc;
		rel[rel.length - 1].x2.yLoc = rel[i].x1.yLoc;
	}

	rel = compress(rel);
	rel = sort(rel);

	document.getElementById("output").innerHTML += text;
	return rel;
}

function makeTrans(rel)
{
	document.getElementById("list").innerHTML = "<p>" + display(rel) + "</p>";
	var k = rel.length;
	var text = "";
	var contin = true;

	while (contin)
	{
		contin = false;
//		k = rel.length;
		for (var i = 0; i < rel.length; i++)
		{
			for (var j = i+1; j < rel.length; j++)
			{
				if (rel[i].x1.value == rel[j].x2.value && !search2(rel, rel[j].x1.value, rel[i].x2.value))		//(a, b) and (c, a)
				{
					contin = true;
					if (document.getElementById("show").checked)
						text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") implies (" + rel[j].x1.value + ", " + rel[i].x2.value + ")<br>";
					rel[rel.length] = new Object();
					rel[rel.length - 1].x1 = new Object();
					rel[rel.length - 1].x2 = new Object();
					rel[rel.length - 1].x1.value = rel[j].x1.value;
					rel[rel.length - 1].x1.xLoc = rel[j].x1.xLoc;
					rel[rel.length - 1].x1.yLoc = rel[j].x1.yLoc;
					rel[rel.length - 1].x2.value = rel[i].x2.value;
					rel[rel.length - 1].x2.xLoc = rel[i].x2.xLoc;
					rel[rel.length - 1].x2.yLoc = rel[i].x2.yLoc;					
				}
				else if (rel[i].x2.value == rel[j].x1.value && !search2(rel, rel[i].x1.value, rel[j].x2.value))	//(a, b) and (b, c)
				{
					contin = true;
					if (document.getElementById("show").checked)
						text += "Elements (" + rel[j].x1.value + ", " + rel[j].x2.value + ") and (" + rel[i].x1.value + ", " + rel[i].x2.value + ") implies (" + rel[i].x1.value + ", " + rel[j].x2.value + ")<br>";
					rel[rel.length] = new Object();
					rel[rel.length - 1].x1 = new Object();
					rel[rel.length - 1].x2 = new Object();
					rel[rel.length - 1].x1.value = rel[i].x1.value;
					rel[rel.length - 1].x1.xLoc = rel[i].x1.xLoc;
					rel[rel.length - 1].x1.yLoc = rel[i].x1.yLoc;
					rel[rel.length - 1].x2.value = rel[j].x2.value;
					rel[rel.length - 1].x2.xLoc = rel[j].x2.xLoc;
					rel[rel.length - 1].x2.yLoc = rel[j].x2.yLoc;
				}
			}
		}
	}

	rel = compress(rel);
	rel = sort(rel);
	document.getElementById("output").innerHTML += text;

	return rel;
}

function operate(rel, univ)
{
 	if (document.getElementById("alg").value == 1)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeSymm(rel);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 2)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeRefl(rel, univ);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 3)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeTrans(rel);
		drawPts(univ);
		drawLines(rel);
	}
 	else if (document.getElementById("alg").value == 4)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
 		rel = makeAntiSymm(rel);
		drawPts(univ);
		drawLines(rel);
	}
	else if (document.getElementById("alg").value == 5)
	{
		clearRect();
		document.getElementById("output").innerHTML = "";
		rel = makeFunct(rel);
		drawPts(univ);
		drawLines(rel);
	}

	return rel;
}

function poset(rel, univ)
{
	var ans = false, text = "";
	var antiSymmAns = antiSymm(rel);
	var reflAns = refl(rel, univ);
	var transAns = trans(rel);

	if (antiSymmAns == "" && reflAns == "" && transAns == "")
		text += "The relation is a Partial Order. <br>";
	else 
	{
		if (antiSymmAns != "")
			text += antiSymmAns + "The relation is not anti-symmtric<br>";
		if (reflAns != "")
			text += reflAns + "The relation is not reflexive<br>";
		if (transAns)
			text += transAns + "The relation is not transitive<br>";
	}

	return text;
}

function range(rel)
{
	var ran = new Array();
	for (var i = 0; i < rel.length; i++)
	{
		if (!search0(ran, rel[i].x2.value))
			ran[ran.length] = rel[i].x2.value;
	}

	return ran;
}

function refl(rel, univ)
{
	var text = "";

	for (var i = 0; i < univ.length && text == ""; i++)
	{
		if ((univ[i].x1.value == univ[i].x2.value) && !search2(rel, univ[i].x1.value, univ[i].x2.value))
			text += "The element (" + univ[i].x1.value + ", " + univ[i].x2.value + ") does not belong to the relation.<br>";
	}

	return text;
}

function remove(set, loc)
{
	set[loc] = set[set.length-1];
	set.length--;
	
	return set;
}

function retreive(set, start, finish)
{
	var i;
	var ans = new Array();
	for (i = start; i < finish; i++)
		ans[ans.length] = set[i];

	return ans;
}

function search0(set, elmnt)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i] == elmnt)
			ans = true;

	return ans;
}

function search1(set, elmnt)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i].x1.value == elmnt)
			ans = true;

	return ans;
}

function search2(set, elmnt1, elmnt2)
{
	var i;
	var ans = false;

	for (i = 0; i < set.length && !ans; i++)
		if (set[i].x1.value == elmnt1 && set[i].x2.value == elmnt2)
			ans = true;

	return ans;
}

function setLocs(rel)
{
	var c = document.getElementById("myCanvas");
	var dom = domain(rel);
	var ran = range(rel);
	var set = union(dom, ran);
	var i, j, temp;

	for (i = 0; i < set.length; i++)
		for (j = i+1; j < set.length; j++)
		{
			if (set[i] > set[j])
			{
				temp = set[i];
				set[i] = set[j];
				set[j] = temp;
			}
		}

	for (i = 0; i < set.length; i++)
	{
		for (j = 0; j < rel.length; j++)
		{
			if (rel[j].x1.value == set[i])
			{
				rel[j].x1.yLoc = i*25 + 25;
				rel[j].x1.xLoc = (0 + c.width) / 5;
			}
			if (rel[j].x2.value == set[i])
			{
				rel[j].x2.yLoc = i*25 + 25;
				rel[j].x2.xLoc = 4*(0 + c.width) / 5;
			}
		}
	}
	return rel;
}

function sort(rel)
{
	var i, j;
	var temp;
	count = 0;
	for (i = 0; i < rel.length; i++)
		for (j = i + 1; j < rel.length; j++)
		{
			if (rel[i].x1.value >  rel[j].x1.value || (rel[i].x1.value == rel[j].x1.value && rel[i].x2.value >  rel[j].x2.value))
			{
				temp = rel[i];
				rel[i] = rel[j];
				rel[j] = temp;
			}
			count++;
		}

	return rel;
}

function symm(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		if (!search2(rel, rel[i].x2.value, rel[i].x1.value))
			text += "The element (" + rel[i].x1.value + ", " + rel[i].x2.value + ") is in the relation, but (" + rel[i].x2.value + ", " + rel[i].x1.value + ") is not. <br>"
	}

	return text;
}

function total(rel, univ)
{
	var text = "";
	var set1 = domain(univ);
	var set2 = range(univ);

	for (var i = 0; i < set1.length && text == ""; i++)
	{
		for (var j = 0; j < set2.length && text == ""; j++)
		{
			if (!search2(rel, set1[i], set2[j]) && !search2(rel, set2[j], set1[i]))
				text += "Elements " + set1[i] + " and " + set2[j] + " are not related. <br>";
		}
	}
	text += poset(rel, univ);

	return text;
}

function trans(rel)
{
	var text = "";

	for (var i = 0; i < rel.length && text == ""; i++)
	{
		for (var j = i + 1; j < rel.length && text == ""; j++)
		{
			if (rel[i].x1.value == rel[j].x2.value)
			{
				if (!search2(rel, rel[j].x1.value, rel[i].x2.value))
					text += "Elements (" + rel[i].x1.value + ", " + rel[i].x2.value + ") and (" + rel[j].x1.value + ", " + rel[j].x2.value + ") belong to this relation, but (" + rel[j].x1.value + ", " + rel[i].x2.value + ") does not. <br>";
			}
			else if (rel[i].x2.value == rel[j].x1.value)
			{
				if (!search2(rel, rel[i].x1.value, rel[j].x2.value))
					text += "Elements (" + rel[j].x1.value + ", " + rel[j].x2.value + ") and (" + rel[i].x1.value + ", " + rel[i].x2.value + ") belong to this relation, but (" + rel[i].x1.value + ", " + rel[j].x2.value + ") does not<br>";
			}
		}
	}

	return text;
}

function union(set1, set2)
{
	var set3 = new Array();
	var i;

	for (i = 0; i < set1.length; i++)
		set3[i] = set1[i];

	for (i = 0; i < set2.length; i++)
	{
		if (!search0(set3, set2[i]))
			set3[set3.length] = set2[i];
	}

	return set3;
}
</script>
<h3><center></center></h3>
<p>This script is an attempt to give users examples of relations in set theory. A relation is randomly generated initially and users have the option of making the relation symmetric, reflexive, transitive, antisymmetric, or a function (via the dropdown list box). Then the buttons allow you to test to see if the relation you've "created" fits into any of the major categories of relations. The ones I have here are Function, Equivalence Relation, Partial Order Set, and Total Order Set. Here are some definitions to help you get started: <br>
<br>
Properties of Relations: <br>
A relation R is <b>symmetric</b> if whenever an element (a, b) belongs to R, then so does (b, a). <br>
<br>
A relation R is <b>reflexive</b> if for every element a in the universe of the relation, the element (a, a) belongs to R. <br>
<br>
A relation R is <b>transitive</b> if for every pair of elements (a, b) and (c, d) and b = c, then the element (a, d) belongs to R. <br>
<br>
A relation R is <b>anti-symmetric</b> if the elements (a, b) and (b, a) do not belong to the relation whenever a is not equal to b. <br>
<br>
Types of Relations: <br>
A relation R is a function (on its set of defined elements) if there do not exist elements (a, b) and (a, c) which both belong to R. <br>
<br>
A relation R is an <b>equivalence relation</b> if R is symmetric, reflexive and transitive. <br>
<br>
A relation R is a <b>partial order set</b> if R is anti-symmetric, reflexive and transitive. <br>
<br>
A relation R is a <b>total order set</b> if it is a partial order set and for every pair of elements a and b, either (a, b) is in R or (b, a) is in R. </p>
<form name=data id=data> 
<input type=button onclick="clearRect();document.getElementById('list').innerHTML = '';k1 = Math.floor(Math.random()*23);ans = init(set1, k1);set1 = ans[0];univ = ans[1]; rel = ans[2]; old_rel = ans[2];" value="New Problem"><br> 
<p id=list name=list></p>
<label>I would like to make this relation </label>
<select name="alg" id="alg">
 <option value=1 selected>Symmetric</OPTION>
 <option value=2>Reflective</OPTION>
 <option value=3>Transitive</OPTION>
 <option value=4>Anti-Symmetric</OPTION>
 <option value=5>A Function</OPTION>
</SELECT><br> 
<input type="checkbox" name="show" id="show">Show Work?
<input type="button" value="Operate" onclick="rel = operate(rel, univ); document.getElementById('output').innerHTML += '<p>Now, rel = ' + display(rel) + '</p>';">  </FORM>
<input type="button" value="Function Test" onclick="document.getElementById('output').innerHTML = '<p>' + isFunct(rel) + '</p>'">
<input type="button" value="Equivalence Relation Test" onclick="document.getElementById('output').innerHTML = '<p>' + equivrel(rel, univ) + '</p>'">
<input type="button" value="Partial Order Test" onclick="document.getElementById('output').innerHTML = '<p>' + poset(rel, univ) + '</p>'">
<input type="button" value="Total Order Test" onclick="document.getElementById('output').innerHTML = '<p>' + total(rel, univ) + '</p>'">
<p name="output" id="output">
</p>
<canvas id="myCanvas" width="550" height="600" style="border:1px solid #d3d3d3;">
your browser does not support the canvas tag
</canvas>
<script type="text/javascript">
var k1 = Math.floor(Math.random()*23);
var set1 = new Array();
var rel;
var univ;
var ans = init(set1, k1);
set1 = ans[0];
univ = ans[1];
rel = ans[2];
var old_rel = ans[2];
</script>
